// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MockPins_test.proto

#ifndef PROTOBUF_INCLUDED_MockPins_5ftest_2eproto
#define PROTOBUF_INCLUDED_MockPins_5ftest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "brewblox_test.pb.h"
#include "nanopb_test.pb.h"
#include "IoArray_test.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_MockPins_5ftest_2eproto 

namespace protobuf_MockPins_5ftest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_MockPins_5ftest_2eproto
namespace blox {
class MockPins;
class MockPinsDefaultTypeInternal;
extern MockPinsDefaultTypeInternal _MockPins_default_instance_;
class MockPinsIoPin;
class MockPinsIoPinDefaultTypeInternal;
extern MockPinsIoPinDefaultTypeInternal _MockPinsIoPin_default_instance_;
}  // namespace blox
namespace google {
namespace protobuf {
template<> ::blox::MockPins* Arena::CreateMaybeMessage<::blox::MockPins>(Arena*);
template<> ::blox::MockPinsIoPin* Arena::CreateMaybeMessage<::blox::MockPinsIoPin>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace blox {

// ===================================================================

class MockPinsIoPin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox.MockPinsIoPin) */ {
 public:
  MockPinsIoPin();
  virtual ~MockPinsIoPin();

  MockPinsIoPin(const MockPinsIoPin& from);

  inline MockPinsIoPin& operator=(const MockPinsIoPin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MockPinsIoPin(MockPinsIoPin&& from) noexcept
    : MockPinsIoPin() {
    *this = ::std::move(from);
  }

  inline MockPinsIoPin& operator=(MockPinsIoPin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MockPinsIoPin& default_instance();

  enum PinCase {
    kMock1 = 1,
    kMock2 = 2,
    kMock3 = 3,
    kMock4 = 4,
    kMock5 = 5,
    kMock6 = 6,
    kMock7 = 7,
    kMock8 = 8,
    PIN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MockPinsIoPin* internal_default_instance() {
    return reinterpret_cast<const MockPinsIoPin*>(
               &_MockPinsIoPin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MockPinsIoPin* other);
  friend void swap(MockPinsIoPin& a, MockPinsIoPin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MockPinsIoPin* New() const final {
    return CreateMaybeMessage<MockPinsIoPin>(NULL);
  }

  MockPinsIoPin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MockPinsIoPin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MockPinsIoPin& from);
  void MergeFrom(const MockPinsIoPin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MockPinsIoPin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .blox.IoChannel mock1 = 1;
  bool has_mock1() const;
  void clear_mock1();
  static const int kMock1FieldNumber = 1;
  private:
  const ::blox::IoChannel& _internal_mock1() const;
  public:
  const ::blox::IoChannel& mock1() const;
  ::blox::IoChannel* release_mock1();
  ::blox::IoChannel* mutable_mock1();
  void set_allocated_mock1(::blox::IoChannel* mock1);

  // .blox.IoChannel mock2 = 2;
  bool has_mock2() const;
  void clear_mock2();
  static const int kMock2FieldNumber = 2;
  private:
  const ::blox::IoChannel& _internal_mock2() const;
  public:
  const ::blox::IoChannel& mock2() const;
  ::blox::IoChannel* release_mock2();
  ::blox::IoChannel* mutable_mock2();
  void set_allocated_mock2(::blox::IoChannel* mock2);

  // .blox.IoChannel mock3 = 3;
  bool has_mock3() const;
  void clear_mock3();
  static const int kMock3FieldNumber = 3;
  private:
  const ::blox::IoChannel& _internal_mock3() const;
  public:
  const ::blox::IoChannel& mock3() const;
  ::blox::IoChannel* release_mock3();
  ::blox::IoChannel* mutable_mock3();
  void set_allocated_mock3(::blox::IoChannel* mock3);

  // .blox.IoChannel mock4 = 4;
  bool has_mock4() const;
  void clear_mock4();
  static const int kMock4FieldNumber = 4;
  private:
  const ::blox::IoChannel& _internal_mock4() const;
  public:
  const ::blox::IoChannel& mock4() const;
  ::blox::IoChannel* release_mock4();
  ::blox::IoChannel* mutable_mock4();
  void set_allocated_mock4(::blox::IoChannel* mock4);

  // .blox.IoChannel mock5 = 5;
  bool has_mock5() const;
  void clear_mock5();
  static const int kMock5FieldNumber = 5;
  private:
  const ::blox::IoChannel& _internal_mock5() const;
  public:
  const ::blox::IoChannel& mock5() const;
  ::blox::IoChannel* release_mock5();
  ::blox::IoChannel* mutable_mock5();
  void set_allocated_mock5(::blox::IoChannel* mock5);

  // .blox.IoChannel mock6 = 6;
  bool has_mock6() const;
  void clear_mock6();
  static const int kMock6FieldNumber = 6;
  private:
  const ::blox::IoChannel& _internal_mock6() const;
  public:
  const ::blox::IoChannel& mock6() const;
  ::blox::IoChannel* release_mock6();
  ::blox::IoChannel* mutable_mock6();
  void set_allocated_mock6(::blox::IoChannel* mock6);

  // .blox.IoChannel mock7 = 7;
  bool has_mock7() const;
  void clear_mock7();
  static const int kMock7FieldNumber = 7;
  private:
  const ::blox::IoChannel& _internal_mock7() const;
  public:
  const ::blox::IoChannel& mock7() const;
  ::blox::IoChannel* release_mock7();
  ::blox::IoChannel* mutable_mock7();
  void set_allocated_mock7(::blox::IoChannel* mock7);

  // .blox.IoChannel mock8 = 8;
  bool has_mock8() const;
  void clear_mock8();
  static const int kMock8FieldNumber = 8;
  private:
  const ::blox::IoChannel& _internal_mock8() const;
  public:
  const ::blox::IoChannel& mock8() const;
  ::blox::IoChannel* release_mock8();
  ::blox::IoChannel* mutable_mock8();
  void set_allocated_mock8(::blox::IoChannel* mock8);

  void clear_Pin();
  PinCase Pin_case() const;
  // @@protoc_insertion_point(class_scope:blox.MockPinsIoPin)
 private:
  void set_has_mock1();
  void set_has_mock2();
  void set_has_mock3();
  void set_has_mock4();
  void set_has_mock5();
  void set_has_mock6();
  void set_has_mock7();
  void set_has_mock8();

  inline bool has_Pin() const;
  inline void clear_has_Pin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PinUnion {
    PinUnion() {}
    ::blox::IoChannel* mock1_;
    ::blox::IoChannel* mock2_;
    ::blox::IoChannel* mock3_;
    ::blox::IoChannel* mock4_;
    ::blox::IoChannel* mock5_;
    ::blox::IoChannel* mock6_;
    ::blox::IoChannel* mock7_;
    ::blox::IoChannel* mock8_;
  } Pin_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_MockPins_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MockPins : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox.MockPins) */ {
 public:
  MockPins();
  virtual ~MockPins();

  MockPins(const MockPins& from);

  inline MockPins& operator=(const MockPins& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MockPins(MockPins&& from) noexcept
    : MockPins() {
    *this = ::std::move(from);
  }

  inline MockPins& operator=(MockPins&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MockPins& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MockPins* internal_default_instance() {
    return reinterpret_cast<const MockPins*>(
               &_MockPins_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MockPins* other);
  friend void swap(MockPins& a, MockPins& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MockPins* New() const final {
    return CreateMaybeMessage<MockPins>(NULL);
  }

  MockPins* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MockPins>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MockPins& from);
  void MergeFrom(const MockPins& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MockPins* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.MockPinsIoPin pins = 1 [(.nanopb_test) = {
  int pins_size() const;
  void clear_pins();
  static const int kPinsFieldNumber = 1;
  ::blox::MockPinsIoPin* mutable_pins(int index);
  ::google::protobuf::RepeatedPtrField< ::blox::MockPinsIoPin >*
      mutable_pins();
  const ::blox::MockPinsIoPin& pins(int index) const;
  ::blox::MockPinsIoPin* add_pins();
  const ::google::protobuf::RepeatedPtrField< ::blox::MockPinsIoPin >&
      pins() const;

  // @@protoc_insertion_point(class_scope:blox.MockPins)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::blox::MockPinsIoPin > pins_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_MockPins_5ftest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MockPinsIoPin

// .blox.IoChannel mock1 = 1;
inline bool MockPinsIoPin::has_mock1() const {
  return Pin_case() == kMock1;
}
inline void MockPinsIoPin::set_has_mock1() {
  _oneof_case_[0] = kMock1;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock1() const {
  return *Pin_.mock1_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock1() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock1)
  if (has_mock1()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock1_;
    Pin_.mock1_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock1() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock1)
  return has_mock1()
      ? *Pin_.mock1_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock1() {
  if (!has_mock1()) {
    clear_Pin();
    set_has_mock1();
    Pin_.mock1_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock1)
  return Pin_.mock1_;
}

// .blox.IoChannel mock2 = 2;
inline bool MockPinsIoPin::has_mock2() const {
  return Pin_case() == kMock2;
}
inline void MockPinsIoPin::set_has_mock2() {
  _oneof_case_[0] = kMock2;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock2() const {
  return *Pin_.mock2_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock2() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock2)
  if (has_mock2()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock2_;
    Pin_.mock2_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock2() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock2)
  return has_mock2()
      ? *Pin_.mock2_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock2() {
  if (!has_mock2()) {
    clear_Pin();
    set_has_mock2();
    Pin_.mock2_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock2)
  return Pin_.mock2_;
}

// .blox.IoChannel mock3 = 3;
inline bool MockPinsIoPin::has_mock3() const {
  return Pin_case() == kMock3;
}
inline void MockPinsIoPin::set_has_mock3() {
  _oneof_case_[0] = kMock3;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock3() const {
  return *Pin_.mock3_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock3() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock3)
  if (has_mock3()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock3_;
    Pin_.mock3_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock3() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock3)
  return has_mock3()
      ? *Pin_.mock3_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock3() {
  if (!has_mock3()) {
    clear_Pin();
    set_has_mock3();
    Pin_.mock3_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock3)
  return Pin_.mock3_;
}

// .blox.IoChannel mock4 = 4;
inline bool MockPinsIoPin::has_mock4() const {
  return Pin_case() == kMock4;
}
inline void MockPinsIoPin::set_has_mock4() {
  _oneof_case_[0] = kMock4;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock4() const {
  return *Pin_.mock4_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock4() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock4)
  if (has_mock4()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock4_;
    Pin_.mock4_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock4() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock4)
  return has_mock4()
      ? *Pin_.mock4_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock4() {
  if (!has_mock4()) {
    clear_Pin();
    set_has_mock4();
    Pin_.mock4_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock4)
  return Pin_.mock4_;
}

// .blox.IoChannel mock5 = 5;
inline bool MockPinsIoPin::has_mock5() const {
  return Pin_case() == kMock5;
}
inline void MockPinsIoPin::set_has_mock5() {
  _oneof_case_[0] = kMock5;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock5() const {
  return *Pin_.mock5_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock5() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock5)
  if (has_mock5()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock5_;
    Pin_.mock5_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock5() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock5)
  return has_mock5()
      ? *Pin_.mock5_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock5() {
  if (!has_mock5()) {
    clear_Pin();
    set_has_mock5();
    Pin_.mock5_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock5)
  return Pin_.mock5_;
}

// .blox.IoChannel mock6 = 6;
inline bool MockPinsIoPin::has_mock6() const {
  return Pin_case() == kMock6;
}
inline void MockPinsIoPin::set_has_mock6() {
  _oneof_case_[0] = kMock6;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock6() const {
  return *Pin_.mock6_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock6() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock6)
  if (has_mock6()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock6_;
    Pin_.mock6_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock6() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock6)
  return has_mock6()
      ? *Pin_.mock6_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock6() {
  if (!has_mock6()) {
    clear_Pin();
    set_has_mock6();
    Pin_.mock6_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock6)
  return Pin_.mock6_;
}

// .blox.IoChannel mock7 = 7;
inline bool MockPinsIoPin::has_mock7() const {
  return Pin_case() == kMock7;
}
inline void MockPinsIoPin::set_has_mock7() {
  _oneof_case_[0] = kMock7;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock7() const {
  return *Pin_.mock7_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock7() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock7)
  if (has_mock7()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock7_;
    Pin_.mock7_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock7() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock7)
  return has_mock7()
      ? *Pin_.mock7_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock7() {
  if (!has_mock7()) {
    clear_Pin();
    set_has_mock7();
    Pin_.mock7_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock7)
  return Pin_.mock7_;
}

// .blox.IoChannel mock8 = 8;
inline bool MockPinsIoPin::has_mock8() const {
  return Pin_case() == kMock8;
}
inline void MockPinsIoPin::set_has_mock8() {
  _oneof_case_[0] = kMock8;
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock8() const {
  return *Pin_.mock8_;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock8() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock8)
  if (has_mock8()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock8_;
    Pin_.mock8_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::mock8() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock8)
  return has_mock8()
      ? *Pin_.mock8_
      : *reinterpret_cast< ::blox::IoChannel*>(&::blox::_IoChannel_default_instance_);
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock8() {
  if (!has_mock8()) {
    clear_Pin();
    set_has_mock8();
    Pin_.mock8_ = CreateMaybeMessage< ::blox::IoChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock8)
  return Pin_.mock8_;
}

inline bool MockPinsIoPin::has_Pin() const {
  return Pin_case() != PIN_NOT_SET;
}
inline void MockPinsIoPin::clear_has_Pin() {
  _oneof_case_[0] = PIN_NOT_SET;
}
inline MockPinsIoPin::PinCase MockPinsIoPin::Pin_case() const {
  return MockPinsIoPin::PinCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MockPins

// repeated .blox.MockPinsIoPin pins = 1 [(.nanopb_test) = {
inline int MockPins::pins_size() const {
  return pins_.size();
}
inline void MockPins::clear_pins() {
  pins_.Clear();
}
inline ::blox::MockPinsIoPin* MockPins::mutable_pins(int index) {
  // @@protoc_insertion_point(field_mutable:blox.MockPins.pins)
  return pins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::blox::MockPinsIoPin >*
MockPins::mutable_pins() {
  // @@protoc_insertion_point(field_mutable_list:blox.MockPins.pins)
  return &pins_;
}
inline const ::blox::MockPinsIoPin& MockPins::pins(int index) const {
  // @@protoc_insertion_point(field_get:blox.MockPins.pins)
  return pins_.Get(index);
}
inline ::blox::MockPinsIoPin* MockPins::add_pins() {
  // @@protoc_insertion_point(field_add:blox.MockPins.pins)
  return pins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::MockPinsIoPin >&
MockPins::pins() const {
  // @@protoc_insertion_point(field_list:blox.MockPins.pins)
  return pins_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace blox

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_MockPins_5ftest_2eproto
