// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MockPins_test.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MockPins_5ftest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MockPins_5ftest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "brewblox_test.pb.h"
#include "nanopb_test.pb.h"
#include "IoArray_test.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MockPins_5ftest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MockPins_5ftest_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MockPins_5ftest_2eproto;
namespace blox {
class MockPins;
struct MockPinsDefaultTypeInternal;
extern MockPinsDefaultTypeInternal _MockPins_default_instance_;
class MockPinsIoPin;
struct MockPinsIoPinDefaultTypeInternal;
extern MockPinsIoPinDefaultTypeInternal _MockPinsIoPin_default_instance_;
}  // namespace blox
PROTOBUF_NAMESPACE_OPEN
template<> ::blox::MockPins* Arena::CreateMaybeMessage<::blox::MockPins>(Arena*);
template<> ::blox::MockPinsIoPin* Arena::CreateMaybeMessage<::blox::MockPinsIoPin>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace blox {

// ===================================================================

class MockPinsIoPin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blox.MockPinsIoPin) */ {
 public:
  inline MockPinsIoPin() : MockPinsIoPin(nullptr) {}
  ~MockPinsIoPin() override;
  explicit constexpr MockPinsIoPin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MockPinsIoPin(const MockPinsIoPin& from);
  MockPinsIoPin(MockPinsIoPin&& from) noexcept
    : MockPinsIoPin() {
    *this = ::std::move(from);
  }

  inline MockPinsIoPin& operator=(const MockPinsIoPin& from) {
    CopyFrom(from);
    return *this;
  }
  inline MockPinsIoPin& operator=(MockPinsIoPin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MockPinsIoPin& default_instance() {
    return *internal_default_instance();
  }
  enum PinCase {
    kMock1 = 1,
    kMock2 = 2,
    kMock3 = 3,
    kMock4 = 4,
    kMock5 = 5,
    kMock6 = 6,
    kMock7 = 7,
    kMock8 = 8,
    PIN_NOT_SET = 0,
  };

  static inline const MockPinsIoPin* internal_default_instance() {
    return reinterpret_cast<const MockPinsIoPin*>(
               &_MockPinsIoPin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MockPinsIoPin& a, MockPinsIoPin& b) {
    a.Swap(&b);
  }
  inline void Swap(MockPinsIoPin* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MockPinsIoPin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MockPinsIoPin* New() const final {
    return new MockPinsIoPin();
  }

  MockPinsIoPin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MockPinsIoPin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MockPinsIoPin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MockPinsIoPin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MockPinsIoPin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blox.MockPinsIoPin";
  }
  protected:
  explicit MockPinsIoPin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMock1FieldNumber = 1,
    kMock2FieldNumber = 2,
    kMock3FieldNumber = 3,
    kMock4FieldNumber = 4,
    kMock5FieldNumber = 5,
    kMock6FieldNumber = 6,
    kMock7FieldNumber = 7,
    kMock8FieldNumber = 8,
  };
  // .blox.IoChannel mock1 = 1;
  bool has_mock1() const;
  private:
  bool _internal_has_mock1() const;
  public:
  void clear_mock1();
  const ::blox::IoChannel& mock1() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock1();
  ::blox::IoChannel* mutable_mock1();
  void set_allocated_mock1(::blox::IoChannel* mock1);
  private:
  const ::blox::IoChannel& _internal_mock1() const;
  ::blox::IoChannel* _internal_mutable_mock1();
  public:
  void unsafe_arena_set_allocated_mock1(
      ::blox::IoChannel* mock1);
  ::blox::IoChannel* unsafe_arena_release_mock1();

  // .blox.IoChannel mock2 = 2;
  bool has_mock2() const;
  private:
  bool _internal_has_mock2() const;
  public:
  void clear_mock2();
  const ::blox::IoChannel& mock2() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock2();
  ::blox::IoChannel* mutable_mock2();
  void set_allocated_mock2(::blox::IoChannel* mock2);
  private:
  const ::blox::IoChannel& _internal_mock2() const;
  ::blox::IoChannel* _internal_mutable_mock2();
  public:
  void unsafe_arena_set_allocated_mock2(
      ::blox::IoChannel* mock2);
  ::blox::IoChannel* unsafe_arena_release_mock2();

  // .blox.IoChannel mock3 = 3;
  bool has_mock3() const;
  private:
  bool _internal_has_mock3() const;
  public:
  void clear_mock3();
  const ::blox::IoChannel& mock3() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock3();
  ::blox::IoChannel* mutable_mock3();
  void set_allocated_mock3(::blox::IoChannel* mock3);
  private:
  const ::blox::IoChannel& _internal_mock3() const;
  ::blox::IoChannel* _internal_mutable_mock3();
  public:
  void unsafe_arena_set_allocated_mock3(
      ::blox::IoChannel* mock3);
  ::blox::IoChannel* unsafe_arena_release_mock3();

  // .blox.IoChannel mock4 = 4;
  bool has_mock4() const;
  private:
  bool _internal_has_mock4() const;
  public:
  void clear_mock4();
  const ::blox::IoChannel& mock4() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock4();
  ::blox::IoChannel* mutable_mock4();
  void set_allocated_mock4(::blox::IoChannel* mock4);
  private:
  const ::blox::IoChannel& _internal_mock4() const;
  ::blox::IoChannel* _internal_mutable_mock4();
  public:
  void unsafe_arena_set_allocated_mock4(
      ::blox::IoChannel* mock4);
  ::blox::IoChannel* unsafe_arena_release_mock4();

  // .blox.IoChannel mock5 = 5;
  bool has_mock5() const;
  private:
  bool _internal_has_mock5() const;
  public:
  void clear_mock5();
  const ::blox::IoChannel& mock5() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock5();
  ::blox::IoChannel* mutable_mock5();
  void set_allocated_mock5(::blox::IoChannel* mock5);
  private:
  const ::blox::IoChannel& _internal_mock5() const;
  ::blox::IoChannel* _internal_mutable_mock5();
  public:
  void unsafe_arena_set_allocated_mock5(
      ::blox::IoChannel* mock5);
  ::blox::IoChannel* unsafe_arena_release_mock5();

  // .blox.IoChannel mock6 = 6;
  bool has_mock6() const;
  private:
  bool _internal_has_mock6() const;
  public:
  void clear_mock6();
  const ::blox::IoChannel& mock6() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock6();
  ::blox::IoChannel* mutable_mock6();
  void set_allocated_mock6(::blox::IoChannel* mock6);
  private:
  const ::blox::IoChannel& _internal_mock6() const;
  ::blox::IoChannel* _internal_mutable_mock6();
  public:
  void unsafe_arena_set_allocated_mock6(
      ::blox::IoChannel* mock6);
  ::blox::IoChannel* unsafe_arena_release_mock6();

  // .blox.IoChannel mock7 = 7;
  bool has_mock7() const;
  private:
  bool _internal_has_mock7() const;
  public:
  void clear_mock7();
  const ::blox::IoChannel& mock7() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock7();
  ::blox::IoChannel* mutable_mock7();
  void set_allocated_mock7(::blox::IoChannel* mock7);
  private:
  const ::blox::IoChannel& _internal_mock7() const;
  ::blox::IoChannel* _internal_mutable_mock7();
  public:
  void unsafe_arena_set_allocated_mock7(
      ::blox::IoChannel* mock7);
  ::blox::IoChannel* unsafe_arena_release_mock7();

  // .blox.IoChannel mock8 = 8;
  bool has_mock8() const;
  private:
  bool _internal_has_mock8() const;
  public:
  void clear_mock8();
  const ::blox::IoChannel& mock8() const;
  PROTOBUF_MUST_USE_RESULT ::blox::IoChannel* release_mock8();
  ::blox::IoChannel* mutable_mock8();
  void set_allocated_mock8(::blox::IoChannel* mock8);
  private:
  const ::blox::IoChannel& _internal_mock8() const;
  ::blox::IoChannel* _internal_mutable_mock8();
  public:
  void unsafe_arena_set_allocated_mock8(
      ::blox::IoChannel* mock8);
  ::blox::IoChannel* unsafe_arena_release_mock8();

  void clear_Pin();
  PinCase Pin_case() const;
  // @@protoc_insertion_point(class_scope:blox.MockPinsIoPin)
 private:
  class _Internal;
  void set_has_mock1();
  void set_has_mock2();
  void set_has_mock3();
  void set_has_mock4();
  void set_has_mock5();
  void set_has_mock6();
  void set_has_mock7();
  void set_has_mock8();

  inline bool has_Pin() const;
  inline void clear_has_Pin();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PinUnion {
    constexpr PinUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::blox::IoChannel* mock1_;
    ::blox::IoChannel* mock2_;
    ::blox::IoChannel* mock3_;
    ::blox::IoChannel* mock4_;
    ::blox::IoChannel* mock5_;
    ::blox::IoChannel* mock6_;
    ::blox::IoChannel* mock7_;
    ::blox::IoChannel* mock8_;
  } Pin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_MockPins_5ftest_2eproto;
};
// -------------------------------------------------------------------

class MockPins final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blox.MockPins) */ {
 public:
  inline MockPins() : MockPins(nullptr) {}
  ~MockPins() override;
  explicit constexpr MockPins(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MockPins(const MockPins& from);
  MockPins(MockPins&& from) noexcept
    : MockPins() {
    *this = ::std::move(from);
  }

  inline MockPins& operator=(const MockPins& from) {
    CopyFrom(from);
    return *this;
  }
  inline MockPins& operator=(MockPins&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MockPins& default_instance() {
    return *internal_default_instance();
  }
  static inline const MockPins* internal_default_instance() {
    return reinterpret_cast<const MockPins*>(
               &_MockPins_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MockPins& a, MockPins& b) {
    a.Swap(&b);
  }
  inline void Swap(MockPins* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MockPins* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MockPins* New() const final {
    return new MockPins();
  }

  MockPins* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MockPins>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MockPins& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MockPins& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MockPins* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blox.MockPins";
  }
  protected:
  explicit MockPins(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPinsFieldNumber = 1,
  };
  // repeated .blox.MockPinsIoPin pins = 1 [(.nanopb_test) = {
  int pins_size() const;
  private:
  int _internal_pins_size() const;
  public:
  void clear_pins();
  ::blox::MockPinsIoPin* mutable_pins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blox::MockPinsIoPin >*
      mutable_pins();
  private:
  const ::blox::MockPinsIoPin& _internal_pins(int index) const;
  ::blox::MockPinsIoPin* _internal_add_pins();
  public:
  const ::blox::MockPinsIoPin& pins(int index) const;
  ::blox::MockPinsIoPin* add_pins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blox::MockPinsIoPin >&
      pins() const;

  // @@protoc_insertion_point(class_scope:blox.MockPins)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blox::MockPinsIoPin > pins_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MockPins_5ftest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MockPinsIoPin

// .blox.IoChannel mock1 = 1;
inline bool MockPinsIoPin::_internal_has_mock1() const {
  return Pin_case() == kMock1;
}
inline bool MockPinsIoPin::has_mock1() const {
  return _internal_has_mock1();
}
inline void MockPinsIoPin::set_has_mock1() {
  _oneof_case_[0] = kMock1;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock1() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock1)
  if (_internal_has_mock1()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock1() const {
  return _internal_has_mock1()
      ? *Pin_.mock1_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock1() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock1)
  return _internal_mock1();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock1)
  if (_internal_has_mock1()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock1_;
    Pin_.mock1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock1(::blox::IoChannel* mock1) {
  clear_Pin();
  if (mock1) {
    set_has_mock1();
    Pin_.mock1_ = mock1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock1)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock1() {
  if (!_internal_has_mock1()) {
    clear_Pin();
    set_has_mock1();
    Pin_.mock1_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock1_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock1() {
  ::blox::IoChannel* _msg = _internal_mutable_mock1();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock1)
  return _msg;
}

// .blox.IoChannel mock2 = 2;
inline bool MockPinsIoPin::_internal_has_mock2() const {
  return Pin_case() == kMock2;
}
inline bool MockPinsIoPin::has_mock2() const {
  return _internal_has_mock2();
}
inline void MockPinsIoPin::set_has_mock2() {
  _oneof_case_[0] = kMock2;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock2() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock2)
  if (_internal_has_mock2()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock2() const {
  return _internal_has_mock2()
      ? *Pin_.mock2_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock2() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock2)
  return _internal_mock2();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock2)
  if (_internal_has_mock2()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock2_;
    Pin_.mock2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock2(::blox::IoChannel* mock2) {
  clear_Pin();
  if (mock2) {
    set_has_mock2();
    Pin_.mock2_ = mock2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock2)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock2() {
  if (!_internal_has_mock2()) {
    clear_Pin();
    set_has_mock2();
    Pin_.mock2_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock2_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock2() {
  ::blox::IoChannel* _msg = _internal_mutable_mock2();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock2)
  return _msg;
}

// .blox.IoChannel mock3 = 3;
inline bool MockPinsIoPin::_internal_has_mock3() const {
  return Pin_case() == kMock3;
}
inline bool MockPinsIoPin::has_mock3() const {
  return _internal_has_mock3();
}
inline void MockPinsIoPin::set_has_mock3() {
  _oneof_case_[0] = kMock3;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock3() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock3)
  if (_internal_has_mock3()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock3() const {
  return _internal_has_mock3()
      ? *Pin_.mock3_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock3() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock3)
  return _internal_mock3();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock3)
  if (_internal_has_mock3()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock3_;
    Pin_.mock3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock3(::blox::IoChannel* mock3) {
  clear_Pin();
  if (mock3) {
    set_has_mock3();
    Pin_.mock3_ = mock3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock3)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock3() {
  if (!_internal_has_mock3()) {
    clear_Pin();
    set_has_mock3();
    Pin_.mock3_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock3_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock3() {
  ::blox::IoChannel* _msg = _internal_mutable_mock3();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock3)
  return _msg;
}

// .blox.IoChannel mock4 = 4;
inline bool MockPinsIoPin::_internal_has_mock4() const {
  return Pin_case() == kMock4;
}
inline bool MockPinsIoPin::has_mock4() const {
  return _internal_has_mock4();
}
inline void MockPinsIoPin::set_has_mock4() {
  _oneof_case_[0] = kMock4;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock4() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock4)
  if (_internal_has_mock4()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock4_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock4_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock4() const {
  return _internal_has_mock4()
      ? *Pin_.mock4_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock4() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock4)
  return _internal_mock4();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock4() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock4)
  if (_internal_has_mock4()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock4_;
    Pin_.mock4_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock4(::blox::IoChannel* mock4) {
  clear_Pin();
  if (mock4) {
    set_has_mock4();
    Pin_.mock4_ = mock4;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock4)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock4() {
  if (!_internal_has_mock4()) {
    clear_Pin();
    set_has_mock4();
    Pin_.mock4_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock4_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock4() {
  ::blox::IoChannel* _msg = _internal_mutable_mock4();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock4)
  return _msg;
}

// .blox.IoChannel mock5 = 5;
inline bool MockPinsIoPin::_internal_has_mock5() const {
  return Pin_case() == kMock5;
}
inline bool MockPinsIoPin::has_mock5() const {
  return _internal_has_mock5();
}
inline void MockPinsIoPin::set_has_mock5() {
  _oneof_case_[0] = kMock5;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock5() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock5)
  if (_internal_has_mock5()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock5_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock5_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock5() const {
  return _internal_has_mock5()
      ? *Pin_.mock5_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock5() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock5)
  return _internal_mock5();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock5() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock5)
  if (_internal_has_mock5()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock5_;
    Pin_.mock5_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock5(::blox::IoChannel* mock5) {
  clear_Pin();
  if (mock5) {
    set_has_mock5();
    Pin_.mock5_ = mock5;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock5)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock5() {
  if (!_internal_has_mock5()) {
    clear_Pin();
    set_has_mock5();
    Pin_.mock5_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock5_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock5() {
  ::blox::IoChannel* _msg = _internal_mutable_mock5();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock5)
  return _msg;
}

// .blox.IoChannel mock6 = 6;
inline bool MockPinsIoPin::_internal_has_mock6() const {
  return Pin_case() == kMock6;
}
inline bool MockPinsIoPin::has_mock6() const {
  return _internal_has_mock6();
}
inline void MockPinsIoPin::set_has_mock6() {
  _oneof_case_[0] = kMock6;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock6() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock6)
  if (_internal_has_mock6()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock6_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock6_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock6() const {
  return _internal_has_mock6()
      ? *Pin_.mock6_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock6() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock6)
  return _internal_mock6();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock6() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock6)
  if (_internal_has_mock6()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock6_;
    Pin_.mock6_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock6(::blox::IoChannel* mock6) {
  clear_Pin();
  if (mock6) {
    set_has_mock6();
    Pin_.mock6_ = mock6;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock6)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock6() {
  if (!_internal_has_mock6()) {
    clear_Pin();
    set_has_mock6();
    Pin_.mock6_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock6_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock6() {
  ::blox::IoChannel* _msg = _internal_mutable_mock6();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock6)
  return _msg;
}

// .blox.IoChannel mock7 = 7;
inline bool MockPinsIoPin::_internal_has_mock7() const {
  return Pin_case() == kMock7;
}
inline bool MockPinsIoPin::has_mock7() const {
  return _internal_has_mock7();
}
inline void MockPinsIoPin::set_has_mock7() {
  _oneof_case_[0] = kMock7;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock7() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock7)
  if (_internal_has_mock7()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock7_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock7_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock7() const {
  return _internal_has_mock7()
      ? *Pin_.mock7_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock7() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock7)
  return _internal_mock7();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock7() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock7)
  if (_internal_has_mock7()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock7_;
    Pin_.mock7_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock7(::blox::IoChannel* mock7) {
  clear_Pin();
  if (mock7) {
    set_has_mock7();
    Pin_.mock7_ = mock7;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock7)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock7() {
  if (!_internal_has_mock7()) {
    clear_Pin();
    set_has_mock7();
    Pin_.mock7_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock7_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock7() {
  ::blox::IoChannel* _msg = _internal_mutable_mock7();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock7)
  return _msg;
}

// .blox.IoChannel mock8 = 8;
inline bool MockPinsIoPin::_internal_has_mock8() const {
  return Pin_case() == kMock8;
}
inline bool MockPinsIoPin::has_mock8() const {
  return _internal_has_mock8();
}
inline void MockPinsIoPin::set_has_mock8() {
  _oneof_case_[0] = kMock8;
}
inline ::blox::IoChannel* MockPinsIoPin::release_mock8() {
  // @@protoc_insertion_point(field_release:blox.MockPinsIoPin.mock8)
  if (_internal_has_mock8()) {
    clear_has_Pin();
      ::blox::IoChannel* temp = Pin_.mock8_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Pin_.mock8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blox::IoChannel& MockPinsIoPin::_internal_mock8() const {
  return _internal_has_mock8()
      ? *Pin_.mock8_
      : reinterpret_cast< ::blox::IoChannel&>(::blox::_IoChannel_default_instance_);
}
inline const ::blox::IoChannel& MockPinsIoPin::mock8() const {
  // @@protoc_insertion_point(field_get:blox.MockPinsIoPin.mock8)
  return _internal_mock8();
}
inline ::blox::IoChannel* MockPinsIoPin::unsafe_arena_release_mock8() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blox.MockPinsIoPin.mock8)
  if (_internal_has_mock8()) {
    clear_has_Pin();
    ::blox::IoChannel* temp = Pin_.mock8_;
    Pin_.mock8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MockPinsIoPin::unsafe_arena_set_allocated_mock8(::blox::IoChannel* mock8) {
  clear_Pin();
  if (mock8) {
    set_has_mock8();
    Pin_.mock8_ = mock8;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blox.MockPinsIoPin.mock8)
}
inline ::blox::IoChannel* MockPinsIoPin::_internal_mutable_mock8() {
  if (!_internal_has_mock8()) {
    clear_Pin();
    set_has_mock8();
    Pin_.mock8_ = CreateMaybeMessage< ::blox::IoChannel >(GetArenaForAllocation());
  }
  return Pin_.mock8_;
}
inline ::blox::IoChannel* MockPinsIoPin::mutable_mock8() {
  ::blox::IoChannel* _msg = _internal_mutable_mock8();
  // @@protoc_insertion_point(field_mutable:blox.MockPinsIoPin.mock8)
  return _msg;
}

inline bool MockPinsIoPin::has_Pin() const {
  return Pin_case() != PIN_NOT_SET;
}
inline void MockPinsIoPin::clear_has_Pin() {
  _oneof_case_[0] = PIN_NOT_SET;
}
inline MockPinsIoPin::PinCase MockPinsIoPin::Pin_case() const {
  return MockPinsIoPin::PinCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MockPins

// repeated .blox.MockPinsIoPin pins = 1 [(.nanopb_test) = {
inline int MockPins::_internal_pins_size() const {
  return pins_.size();
}
inline int MockPins::pins_size() const {
  return _internal_pins_size();
}
inline void MockPins::clear_pins() {
  pins_.Clear();
}
inline ::blox::MockPinsIoPin* MockPins::mutable_pins(int index) {
  // @@protoc_insertion_point(field_mutable:blox.MockPins.pins)
  return pins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blox::MockPinsIoPin >*
MockPins::mutable_pins() {
  // @@protoc_insertion_point(field_mutable_list:blox.MockPins.pins)
  return &pins_;
}
inline const ::blox::MockPinsIoPin& MockPins::_internal_pins(int index) const {
  return pins_.Get(index);
}
inline const ::blox::MockPinsIoPin& MockPins::pins(int index) const {
  // @@protoc_insertion_point(field_get:blox.MockPins.pins)
  return _internal_pins(index);
}
inline ::blox::MockPinsIoPin* MockPins::_internal_add_pins() {
  return pins_.Add();
}
inline ::blox::MockPinsIoPin* MockPins::add_pins() {
  ::blox::MockPinsIoPin* _add = _internal_add_pins();
  // @@protoc_insertion_point(field_add:blox.MockPins.pins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blox::MockPinsIoPin >&
MockPins::pins() const {
  // @@protoc_insertion_point(field_list:blox.MockPins.pins)
  return pins_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace blox

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MockPins_5ftest_2eproto
