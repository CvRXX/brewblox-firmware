// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Sequence_test.proto

#ifndef PROTOBUF_INCLUDED_Sequence_5ftest_2eproto
#define PROTOBUF_INCLUDED_Sequence_5ftest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "brewblox_test.pb.h"
#include "nanopb_test.pb.h"
#include "IoArray_test.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Sequence_5ftest_2eproto 

namespace protobuf_Sequence_5ftest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Sequence_5ftest_2eproto
namespace blox_test {
namespace Sequence {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class EnableDisable;
class EnableDisableDefaultTypeInternal;
extern EnableDisableDefaultTypeInternal _EnableDisable_default_instance_;
class Instruction;
class InstructionDefaultTypeInternal;
extern InstructionDefaultTypeInternal _Instruction_default_instance_;
class InstructionReset;
class InstructionResetDefaultTypeInternal;
extern InstructionResetDefaultTypeInternal _InstructionReset_default_instance_;
class Restart;
class RestartDefaultTypeInternal;
extern RestartDefaultTypeInternal _Restart_default_instance_;
class SetDigital;
class SetDigitalDefaultTypeInternal;
extern SetDigitalDefaultTypeInternal _SetDigital_default_instance_;
class SetPwm;
class SetPwmDefaultTypeInternal;
extern SetPwmDefaultTypeInternal _SetPwm_default_instance_;
class SetSetpoint;
class SetSetpointDefaultTypeInternal;
extern SetSetpointDefaultTypeInternal _SetSetpoint_default_instance_;
class StartWaitProfile;
class StartWaitProfileDefaultTypeInternal;
extern StartWaitProfileDefaultTypeInternal _StartWaitProfile_default_instance_;
class StartWaitSequence;
class StartWaitSequenceDefaultTypeInternal;
extern StartWaitSequenceDefaultTypeInternal _StartWaitSequence_default_instance_;
class WaitDigital;
class WaitDigitalDefaultTypeInternal;
extern WaitDigitalDefaultTypeInternal _WaitDigital_default_instance_;
class WaitDuration;
class WaitDurationDefaultTypeInternal;
extern WaitDurationDefaultTypeInternal _WaitDuration_default_instance_;
class WaitPwm;
class WaitPwmDefaultTypeInternal;
extern WaitPwmDefaultTypeInternal _WaitPwm_default_instance_;
class WaitSetpoint;
class WaitSetpointDefaultTypeInternal;
extern WaitSetpointDefaultTypeInternal _WaitSetpoint_default_instance_;
class WaitTemperature;
class WaitTemperatureDefaultTypeInternal;
extern WaitTemperatureDefaultTypeInternal _WaitTemperature_default_instance_;
class WaitTemperatureBoundary;
class WaitTemperatureBoundaryDefaultTypeInternal;
extern WaitTemperatureBoundaryDefaultTypeInternal _WaitTemperatureBoundary_default_instance_;
class WaitUntil;
class WaitUntilDefaultTypeInternal;
extern WaitUntilDefaultTypeInternal _WaitUntil_default_instance_;
}  // namespace Sequence
}  // namespace blox_test
namespace google {
namespace protobuf {
template<> ::blox_test::Sequence::Block* Arena::CreateMaybeMessage<::blox_test::Sequence::Block>(Arena*);
template<> ::blox_test::Sequence::EnableDisable* Arena::CreateMaybeMessage<::blox_test::Sequence::EnableDisable>(Arena*);
template<> ::blox_test::Sequence::Instruction* Arena::CreateMaybeMessage<::blox_test::Sequence::Instruction>(Arena*);
template<> ::blox_test::Sequence::InstructionReset* Arena::CreateMaybeMessage<::blox_test::Sequence::InstructionReset>(Arena*);
template<> ::blox_test::Sequence::Restart* Arena::CreateMaybeMessage<::blox_test::Sequence::Restart>(Arena*);
template<> ::blox_test::Sequence::SetDigital* Arena::CreateMaybeMessage<::blox_test::Sequence::SetDigital>(Arena*);
template<> ::blox_test::Sequence::SetPwm* Arena::CreateMaybeMessage<::blox_test::Sequence::SetPwm>(Arena*);
template<> ::blox_test::Sequence::SetSetpoint* Arena::CreateMaybeMessage<::blox_test::Sequence::SetSetpoint>(Arena*);
template<> ::blox_test::Sequence::StartWaitProfile* Arena::CreateMaybeMessage<::blox_test::Sequence::StartWaitProfile>(Arena*);
template<> ::blox_test::Sequence::StartWaitSequence* Arena::CreateMaybeMessage<::blox_test::Sequence::StartWaitSequence>(Arena*);
template<> ::blox_test::Sequence::WaitDigital* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitDigital>(Arena*);
template<> ::blox_test::Sequence::WaitDuration* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitDuration>(Arena*);
template<> ::blox_test::Sequence::WaitPwm* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitPwm>(Arena*);
template<> ::blox_test::Sequence::WaitSetpoint* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitSetpoint>(Arena*);
template<> ::blox_test::Sequence::WaitTemperature* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitTemperature>(Arena*);
template<> ::blox_test::Sequence::WaitTemperatureBoundary* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitTemperatureBoundary>(Arena*);
template<> ::blox_test::Sequence::WaitUntil* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitUntil>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace blox_test {
namespace Sequence {

enum SequenceStatus {
  UNKNOWN = 0,
  DISABLED = 1,
  PAUSED = 2,
  ACTIVE = 3,
  WAITING = 4,
  DONE = 5,
  RESTART = 6,
  ERROR = 7,
  SequenceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SequenceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SequenceStatus_IsValid(int value);
const SequenceStatus SequenceStatus_MIN = UNKNOWN;
const SequenceStatus SequenceStatus_MAX = ERROR;
const int SequenceStatus_ARRAYSIZE = SequenceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SequenceStatus_descriptor();
inline const ::std::string& SequenceStatus_Name(SequenceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SequenceStatus_descriptor(), value);
}
inline bool SequenceStatus_Parse(
    const ::std::string& name, SequenceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SequenceStatus>(
    SequenceStatus_descriptor(), name, value);
}
enum SequenceError {
  NONE = 0,
  INVALID_ARGUMENT = 1,
  INVALID_TARGET = 2,
  INVALID_TARGET_TYPE = 3,
  DISABLED_TARGET = 4,
  SYSTEM_TIME_NOT_AVAILABLE = 5,
  SequenceError_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SequenceError_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SequenceError_IsValid(int value);
const SequenceError SequenceError_MIN = NONE;
const SequenceError SequenceError_MAX = SYSTEM_TIME_NOT_AVAILABLE;
const int SequenceError_ARRAYSIZE = SequenceError_MAX + 1;

const ::google::protobuf::EnumDescriptor* SequenceError_descriptor();
inline const ::std::string& SequenceError_Name(SequenceError value) {
  return ::google::protobuf::internal::NameOfEnum(
    SequenceError_descriptor(), value);
}
inline bool SequenceError_Parse(
    const ::std::string& name, SequenceError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SequenceError>(
    SequenceError_descriptor(), name, value);
}
// ===================================================================

class Restart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.Restart) */ {
 public:
  Restart();
  virtual ~Restart();

  Restart(const Restart& from);

  inline Restart& operator=(const Restart& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Restart(Restart&& from) noexcept
    : Restart() {
    *this = ::std::move(from);
  }

  inline Restart& operator=(Restart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Restart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Restart* internal_default_instance() {
    return reinterpret_cast<const Restart*>(
               &_Restart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Restart* other);
  friend void swap(Restart& a, Restart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Restart* New() const final {
    return CreateMaybeMessage<Restart>(NULL);
  }

  Restart* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Restart>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Restart& from);
  void MergeFrom(const Restart& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Restart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.Restart)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnableDisable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.EnableDisable) */ {
 public:
  EnableDisable();
  virtual ~EnableDisable();

  EnableDisable(const EnableDisable& from);

  inline EnableDisable& operator=(const EnableDisable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnableDisable(EnableDisable&& from) noexcept
    : EnableDisable() {
    *this = ::std::move(from);
  }

  inline EnableDisable& operator=(EnableDisable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableDisable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnableDisable* internal_default_instance() {
    return reinterpret_cast<const EnableDisable*>(
               &_EnableDisable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EnableDisable* other);
  friend void swap(EnableDisable& a, EnableDisable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnableDisable* New() const final {
    return CreateMaybeMessage<EnableDisable>(NULL);
  }

  EnableDisable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnableDisable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnableDisable& from);
  void MergeFrom(const EnableDisable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableDisable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.EnableDisable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitDuration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitDuration) */ {
 public:
  WaitDuration();
  virtual ~WaitDuration();

  WaitDuration(const WaitDuration& from);

  inline WaitDuration& operator=(const WaitDuration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitDuration(WaitDuration&& from) noexcept
    : WaitDuration() {
    *this = ::std::move(from);
  }

  inline WaitDuration& operator=(WaitDuration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitDuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitDuration* internal_default_instance() {
    return reinterpret_cast<const WaitDuration*>(
               &_WaitDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WaitDuration* other);
  friend void swap(WaitDuration& a, WaitDuration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitDuration* New() const final {
    return CreateMaybeMessage<WaitDuration>(NULL);
  }

  WaitDuration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitDuration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitDuration& from);
  void MergeFrom(const WaitDuration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitDuration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 duration = 1 [(.nanopb) = {
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitDuration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitUntil : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitUntil) */ {
 public:
  WaitUntil();
  virtual ~WaitUntil();

  WaitUntil(const WaitUntil& from);

  inline WaitUntil& operator=(const WaitUntil& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitUntil(WaitUntil&& from) noexcept
    : WaitUntil() {
    *this = ::std::move(from);
  }

  inline WaitUntil& operator=(WaitUntil&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitUntil& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitUntil* internal_default_instance() {
    return reinterpret_cast<const WaitUntil*>(
               &_WaitUntil_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(WaitUntil* other);
  friend void swap(WaitUntil& a, WaitUntil& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitUntil* New() const final {
    return CreateMaybeMessage<WaitUntil>(NULL);
  }

  WaitUntil* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitUntil>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitUntil& from);
  void MergeFrom(const WaitUntil& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitUntil* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 time = 1 [(.nanopb) = {
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitUntil)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitTemperature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitTemperature) */ {
 public:
  WaitTemperature();
  virtual ~WaitTemperature();

  WaitTemperature(const WaitTemperature& from);

  inline WaitTemperature& operator=(const WaitTemperature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitTemperature(WaitTemperature&& from) noexcept
    : WaitTemperature() {
    *this = ::std::move(from);
  }

  inline WaitTemperature& operator=(WaitTemperature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitTemperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitTemperature* internal_default_instance() {
    return reinterpret_cast<const WaitTemperature*>(
               &_WaitTemperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WaitTemperature* other);
  friend void swap(WaitTemperature& a, WaitTemperature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitTemperature* New() const final {
    return CreateMaybeMessage<WaitTemperature>(NULL);
  }

  WaitTemperature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitTemperature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitTemperature& from);
  void MergeFrom(const WaitTemperature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitTemperature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 lower = 2 [(.nanopb) = {
  void clear_lower();
  static const int kLowerFieldNumber = 2;
  ::google::protobuf::int32 lower() const;
  void set_lower(::google::protobuf::int32 value);

  // sint32 upper = 3 [(.nanopb) = {
  void clear_upper();
  static const int kUpperFieldNumber = 3;
  ::google::protobuf::int32 upper() const;
  void set_upper(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitTemperature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 lower_;
  ::google::protobuf::int32 upper_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitTemperatureBoundary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitTemperatureBoundary) */ {
 public:
  WaitTemperatureBoundary();
  virtual ~WaitTemperatureBoundary();

  WaitTemperatureBoundary(const WaitTemperatureBoundary& from);

  inline WaitTemperatureBoundary& operator=(const WaitTemperatureBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitTemperatureBoundary(WaitTemperatureBoundary&& from) noexcept
    : WaitTemperatureBoundary() {
    *this = ::std::move(from);
  }

  inline WaitTemperatureBoundary& operator=(WaitTemperatureBoundary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitTemperatureBoundary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitTemperatureBoundary* internal_default_instance() {
    return reinterpret_cast<const WaitTemperatureBoundary*>(
               &_WaitTemperatureBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(WaitTemperatureBoundary* other);
  friend void swap(WaitTemperatureBoundary& a, WaitTemperatureBoundary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitTemperatureBoundary* New() const final {
    return CreateMaybeMessage<WaitTemperatureBoundary>(NULL);
  }

  WaitTemperatureBoundary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitTemperatureBoundary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitTemperatureBoundary& from);
  void MergeFrom(const WaitTemperatureBoundary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitTemperatureBoundary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 value = 2 [(.nanopb) = {
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitTemperatureBoundary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetSetpoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.SetSetpoint) */ {
 public:
  SetSetpoint();
  virtual ~SetSetpoint();

  SetSetpoint(const SetSetpoint& from);

  inline SetSetpoint& operator=(const SetSetpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetSetpoint(SetSetpoint&& from) noexcept
    : SetSetpoint() {
    *this = ::std::move(from);
  }

  inline SetSetpoint& operator=(SetSetpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetSetpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetSetpoint* internal_default_instance() {
    return reinterpret_cast<const SetSetpoint*>(
               &_SetSetpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SetSetpoint* other);
  friend void swap(SetSetpoint& a, SetSetpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetSetpoint* New() const final {
    return CreateMaybeMessage<SetSetpoint>(NULL);
  }

  SetSetpoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetSetpoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetSetpoint& from);
  void MergeFrom(const SetSetpoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSetpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 setting = 2 [(.nanopb) = {
  void clear_setting();
  static const int kSettingFieldNumber = 2;
  ::google::protobuf::int32 setting() const;
  void set_setting(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.SetSetpoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 setting_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitSetpoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitSetpoint) */ {
 public:
  WaitSetpoint();
  virtual ~WaitSetpoint();

  WaitSetpoint(const WaitSetpoint& from);

  inline WaitSetpoint& operator=(const WaitSetpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitSetpoint(WaitSetpoint&& from) noexcept
    : WaitSetpoint() {
    *this = ::std::move(from);
  }

  inline WaitSetpoint& operator=(WaitSetpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitSetpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitSetpoint* internal_default_instance() {
    return reinterpret_cast<const WaitSetpoint*>(
               &_WaitSetpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WaitSetpoint* other);
  friend void swap(WaitSetpoint& a, WaitSetpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitSetpoint* New() const final {
    return CreateMaybeMessage<WaitSetpoint>(NULL);
  }

  WaitSetpoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitSetpoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitSetpoint& from);
  void MergeFrom(const WaitSetpoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitSetpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 precision = 2 [(.nanopb) = {
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitSetpoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 precision_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetDigital : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.SetDigital) */ {
 public:
  SetDigital();
  virtual ~SetDigital();

  SetDigital(const SetDigital& from);

  inline SetDigital& operator=(const SetDigital& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetDigital(SetDigital&& from) noexcept
    : SetDigital() {
    *this = ::std::move(from);
  }

  inline SetDigital& operator=(SetDigital&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDigital& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetDigital* internal_default_instance() {
    return reinterpret_cast<const SetDigital*>(
               &_SetDigital_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SetDigital* other);
  friend void swap(SetDigital& a, SetDigital& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetDigital* New() const final {
    return CreateMaybeMessage<SetDigital>(NULL);
  }

  SetDigital* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetDigital>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetDigital& from);
  void MergeFrom(const SetDigital& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDigital* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // .blox_test.IoArray.DigitalState setting = 2;
  void clear_setting();
  static const int kSettingFieldNumber = 2;
  ::blox_test::IoArray::DigitalState setting() const;
  void set_setting(::blox_test::IoArray::DigitalState value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.SetDigital)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  int setting_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitDigital : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitDigital) */ {
 public:
  WaitDigital();
  virtual ~WaitDigital();

  WaitDigital(const WaitDigital& from);

  inline WaitDigital& operator=(const WaitDigital& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitDigital(WaitDigital&& from) noexcept
    : WaitDigital() {
    *this = ::std::move(from);
  }

  inline WaitDigital& operator=(WaitDigital&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitDigital& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitDigital* internal_default_instance() {
    return reinterpret_cast<const WaitDigital*>(
               &_WaitDigital_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(WaitDigital* other);
  friend void swap(WaitDigital& a, WaitDigital& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitDigital* New() const final {
    return CreateMaybeMessage<WaitDigital>(NULL);
  }

  WaitDigital* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitDigital>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitDigital& from);
  void MergeFrom(const WaitDigital& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitDigital* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitDigital)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetPwm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.SetPwm) */ {
 public:
  SetPwm();
  virtual ~SetPwm();

  SetPwm(const SetPwm& from);

  inline SetPwm& operator=(const SetPwm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetPwm(SetPwm&& from) noexcept
    : SetPwm() {
    *this = ::std::move(from);
  }

  inline SetPwm& operator=(SetPwm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPwm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetPwm* internal_default_instance() {
    return reinterpret_cast<const SetPwm*>(
               &_SetPwm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SetPwm* other);
  friend void swap(SetPwm& a, SetPwm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetPwm* New() const final {
    return CreateMaybeMessage<SetPwm>(NULL);
  }

  SetPwm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetPwm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetPwm& from);
  void MergeFrom(const SetPwm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPwm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 setting = 2 [(.nanopb) = {
  void clear_setting();
  static const int kSettingFieldNumber = 2;
  ::google::protobuf::int32 setting() const;
  void set_setting(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.SetPwm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 setting_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitPwm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitPwm) */ {
 public:
  WaitPwm();
  virtual ~WaitPwm();

  WaitPwm(const WaitPwm& from);

  inline WaitPwm& operator=(const WaitPwm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitPwm(WaitPwm&& from) noexcept
    : WaitPwm() {
    *this = ::std::move(from);
  }

  inline WaitPwm& operator=(WaitPwm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitPwm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitPwm* internal_default_instance() {
    return reinterpret_cast<const WaitPwm*>(
               &_WaitPwm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(WaitPwm* other);
  friend void swap(WaitPwm& a, WaitPwm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitPwm* New() const final {
    return CreateMaybeMessage<WaitPwm>(NULL);
  }

  WaitPwm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitPwm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitPwm& from);
  void MergeFrom(const WaitPwm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitPwm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 precision = 2 [(.nanopb) = {
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitPwm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 precision_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartWaitProfile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.StartWaitProfile) */ {
 public:
  StartWaitProfile();
  virtual ~StartWaitProfile();

  StartWaitProfile(const StartWaitProfile& from);

  inline StartWaitProfile& operator=(const StartWaitProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartWaitProfile(StartWaitProfile&& from) noexcept
    : StartWaitProfile() {
    *this = ::std::move(from);
  }

  inline StartWaitProfile& operator=(StartWaitProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartWaitProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartWaitProfile* internal_default_instance() {
    return reinterpret_cast<const StartWaitProfile*>(
               &_StartWaitProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(StartWaitProfile* other);
  friend void swap(StartWaitProfile& a, StartWaitProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartWaitProfile* New() const final {
    return CreateMaybeMessage<StartWaitProfile>(NULL);
  }

  StartWaitProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartWaitProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartWaitProfile& from);
  void MergeFrom(const StartWaitProfile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartWaitProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.StartWaitProfile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartWaitSequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.StartWaitSequence) */ {
 public:
  StartWaitSequence();
  virtual ~StartWaitSequence();

  StartWaitSequence(const StartWaitSequence& from);

  inline StartWaitSequence& operator=(const StartWaitSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartWaitSequence(StartWaitSequence&& from) noexcept
    : StartWaitSequence() {
    *this = ::std::move(from);
  }

  inline StartWaitSequence& operator=(StartWaitSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartWaitSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartWaitSequence* internal_default_instance() {
    return reinterpret_cast<const StartWaitSequence*>(
               &_StartWaitSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StartWaitSequence* other);
  friend void swap(StartWaitSequence& a, StartWaitSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartWaitSequence* New() const final {
    return CreateMaybeMessage<StartWaitSequence>(NULL);
  }

  StartWaitSequence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartWaitSequence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartWaitSequence& from);
  void MergeFrom(const StartWaitSequence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartWaitSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.StartWaitSequence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Instruction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.Instruction) */ {
 public:
  Instruction();
  virtual ~Instruction();

  Instruction(const Instruction& from);

  inline Instruction& operator=(const Instruction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instruction(Instruction&& from) noexcept
    : Instruction() {
    *this = ::std::move(from);
  }

  inline Instruction& operator=(Instruction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instruction& default_instance();

  enum InstructionOneofCase {
    kRESTART = 1,
    kENABLE = 2,
    kDISABLE = 3,
    kWAITDURATION = 4,
    kWAITUNTIL = 5,
    kWAITTEMPERATUREBETWEEN = 6,
    kWAITTEMPERATUREABOVE = 7,
    kWAITTEMPERATUREBELOW = 8,
    kSETSETPOINT = 9,
    kWAITSETPOINT = 10,
    kSETDIGITAL = 11,
    kWAITDIGITAL = 12,
    kSETPWM = 13,
    kWAITPWM = 14,
    kSTARTPROFILE = 15,
    kWAITPROFILE = 16,
    kSTARTSEQUENCE = 17,
    kWAITSEQUENCE = 18,
    INSTRUCTION_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instruction* internal_default_instance() {
    return reinterpret_cast<const Instruction*>(
               &_Instruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Instruction* other);
  friend void swap(Instruction& a, Instruction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instruction* New() const final {
    return CreateMaybeMessage<Instruction>(NULL);
  }

  Instruction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instruction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instruction& from);
  void MergeFrom(const Instruction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instruction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .blox_test.Sequence.Restart RESTART = 1;
  bool has_restart() const;
  void clear_restart();
  static const int kRESTARTFieldNumber = 1;
  private:
  const ::blox_test::Sequence::Restart& _internal_restart() const;
  public:
  const ::blox_test::Sequence::Restart& restart() const;
  ::blox_test::Sequence::Restart* release_restart();
  ::blox_test::Sequence::Restart* mutable_restart();
  void set_allocated_restart(::blox_test::Sequence::Restart* restart);

  // .blox_test.Sequence.EnableDisable ENABLE = 2;
  bool has_enable() const;
  void clear_enable();
  static const int kENABLEFieldNumber = 2;
  private:
  const ::blox_test::Sequence::EnableDisable& _internal_enable() const;
  public:
  const ::blox_test::Sequence::EnableDisable& enable() const;
  ::blox_test::Sequence::EnableDisable* release_enable();
  ::blox_test::Sequence::EnableDisable* mutable_enable();
  void set_allocated_enable(::blox_test::Sequence::EnableDisable* enable);

  // .blox_test.Sequence.EnableDisable DISABLE = 3;
  bool has_disable() const;
  void clear_disable();
  static const int kDISABLEFieldNumber = 3;
  private:
  const ::blox_test::Sequence::EnableDisable& _internal_disable() const;
  public:
  const ::blox_test::Sequence::EnableDisable& disable() const;
  ::blox_test::Sequence::EnableDisable* release_disable();
  ::blox_test::Sequence::EnableDisable* mutable_disable();
  void set_allocated_disable(::blox_test::Sequence::EnableDisable* disable);

  // .blox_test.Sequence.WaitDuration WAIT_DURATION = 4;
  bool has_wait_duration() const;
  void clear_wait_duration();
  static const int kWAITDURATIONFieldNumber = 4;
  private:
  const ::blox_test::Sequence::WaitDuration& _internal_wait_duration() const;
  public:
  const ::blox_test::Sequence::WaitDuration& wait_duration() const;
  ::blox_test::Sequence::WaitDuration* release_wait_duration();
  ::blox_test::Sequence::WaitDuration* mutable_wait_duration();
  void set_allocated_wait_duration(::blox_test::Sequence::WaitDuration* wait_duration);

  // .blox_test.Sequence.WaitUntil WAIT_UNTIL = 5;
  bool has_wait_until() const;
  void clear_wait_until();
  static const int kWAITUNTILFieldNumber = 5;
  private:
  const ::blox_test::Sequence::WaitUntil& _internal_wait_until() const;
  public:
  const ::blox_test::Sequence::WaitUntil& wait_until() const;
  ::blox_test::Sequence::WaitUntil* release_wait_until();
  ::blox_test::Sequence::WaitUntil* mutable_wait_until();
  void set_allocated_wait_until(::blox_test::Sequence::WaitUntil* wait_until);

  // .blox_test.Sequence.WaitTemperature WAIT_TEMPERATURE_BETWEEN = 6;
  bool has_wait_temperature_between() const;
  void clear_wait_temperature_between();
  static const int kWAITTEMPERATUREBETWEENFieldNumber = 6;
  private:
  const ::blox_test::Sequence::WaitTemperature& _internal_wait_temperature_between() const;
  public:
  const ::blox_test::Sequence::WaitTemperature& wait_temperature_between() const;
  ::blox_test::Sequence::WaitTemperature* release_wait_temperature_between();
  ::blox_test::Sequence::WaitTemperature* mutable_wait_temperature_between();
  void set_allocated_wait_temperature_between(::blox_test::Sequence::WaitTemperature* wait_temperature_between);

  // .blox_test.Sequence.WaitTemperatureBoundary WAIT_TEMPERATURE_ABOVE = 7;
  bool has_wait_temperature_above() const;
  void clear_wait_temperature_above();
  static const int kWAITTEMPERATUREABOVEFieldNumber = 7;
  private:
  const ::blox_test::Sequence::WaitTemperatureBoundary& _internal_wait_temperature_above() const;
  public:
  const ::blox_test::Sequence::WaitTemperatureBoundary& wait_temperature_above() const;
  ::blox_test::Sequence::WaitTemperatureBoundary* release_wait_temperature_above();
  ::blox_test::Sequence::WaitTemperatureBoundary* mutable_wait_temperature_above();
  void set_allocated_wait_temperature_above(::blox_test::Sequence::WaitTemperatureBoundary* wait_temperature_above);

  // .blox_test.Sequence.WaitTemperatureBoundary WAIT_TEMPERATURE_BELOW = 8;
  bool has_wait_temperature_below() const;
  void clear_wait_temperature_below();
  static const int kWAITTEMPERATUREBELOWFieldNumber = 8;
  private:
  const ::blox_test::Sequence::WaitTemperatureBoundary& _internal_wait_temperature_below() const;
  public:
  const ::blox_test::Sequence::WaitTemperatureBoundary& wait_temperature_below() const;
  ::blox_test::Sequence::WaitTemperatureBoundary* release_wait_temperature_below();
  ::blox_test::Sequence::WaitTemperatureBoundary* mutable_wait_temperature_below();
  void set_allocated_wait_temperature_below(::blox_test::Sequence::WaitTemperatureBoundary* wait_temperature_below);

  // .blox_test.Sequence.SetSetpoint SET_SETPOINT = 9;
  bool has_set_setpoint() const;
  void clear_set_setpoint();
  static const int kSETSETPOINTFieldNumber = 9;
  private:
  const ::blox_test::Sequence::SetSetpoint& _internal_set_setpoint() const;
  public:
  const ::blox_test::Sequence::SetSetpoint& set_setpoint() const;
  ::blox_test::Sequence::SetSetpoint* release_set_setpoint();
  ::blox_test::Sequence::SetSetpoint* mutable_set_setpoint();
  void set_allocated_set_setpoint(::blox_test::Sequence::SetSetpoint* set_setpoint);

  // .blox_test.Sequence.WaitSetpoint WAIT_SETPOINT = 10;
  bool has_wait_setpoint() const;
  void clear_wait_setpoint();
  static const int kWAITSETPOINTFieldNumber = 10;
  private:
  const ::blox_test::Sequence::WaitSetpoint& _internal_wait_setpoint() const;
  public:
  const ::blox_test::Sequence::WaitSetpoint& wait_setpoint() const;
  ::blox_test::Sequence::WaitSetpoint* release_wait_setpoint();
  ::blox_test::Sequence::WaitSetpoint* mutable_wait_setpoint();
  void set_allocated_wait_setpoint(::blox_test::Sequence::WaitSetpoint* wait_setpoint);

  // .blox_test.Sequence.SetDigital SET_DIGITAL = 11;
  bool has_set_digital() const;
  void clear_set_digital();
  static const int kSETDIGITALFieldNumber = 11;
  private:
  const ::blox_test::Sequence::SetDigital& _internal_set_digital() const;
  public:
  const ::blox_test::Sequence::SetDigital& set_digital() const;
  ::blox_test::Sequence::SetDigital* release_set_digital();
  ::blox_test::Sequence::SetDigital* mutable_set_digital();
  void set_allocated_set_digital(::blox_test::Sequence::SetDigital* set_digital);

  // .blox_test.Sequence.WaitDigital WAIT_DIGITAL = 12;
  bool has_wait_digital() const;
  void clear_wait_digital();
  static const int kWAITDIGITALFieldNumber = 12;
  private:
  const ::blox_test::Sequence::WaitDigital& _internal_wait_digital() const;
  public:
  const ::blox_test::Sequence::WaitDigital& wait_digital() const;
  ::blox_test::Sequence::WaitDigital* release_wait_digital();
  ::blox_test::Sequence::WaitDigital* mutable_wait_digital();
  void set_allocated_wait_digital(::blox_test::Sequence::WaitDigital* wait_digital);

  // .blox_test.Sequence.SetPwm SET_PWM = 13;
  bool has_set_pwm() const;
  void clear_set_pwm();
  static const int kSETPWMFieldNumber = 13;
  private:
  const ::blox_test::Sequence::SetPwm& _internal_set_pwm() const;
  public:
  const ::blox_test::Sequence::SetPwm& set_pwm() const;
  ::blox_test::Sequence::SetPwm* release_set_pwm();
  ::blox_test::Sequence::SetPwm* mutable_set_pwm();
  void set_allocated_set_pwm(::blox_test::Sequence::SetPwm* set_pwm);

  // .blox_test.Sequence.WaitPwm WAIT_PWM = 14;
  bool has_wait_pwm() const;
  void clear_wait_pwm();
  static const int kWAITPWMFieldNumber = 14;
  private:
  const ::blox_test::Sequence::WaitPwm& _internal_wait_pwm() const;
  public:
  const ::blox_test::Sequence::WaitPwm& wait_pwm() const;
  ::blox_test::Sequence::WaitPwm* release_wait_pwm();
  ::blox_test::Sequence::WaitPwm* mutable_wait_pwm();
  void set_allocated_wait_pwm(::blox_test::Sequence::WaitPwm* wait_pwm);

  // .blox_test.Sequence.StartWaitProfile START_PROFILE = 15;
  bool has_start_profile() const;
  void clear_start_profile();
  static const int kSTARTPROFILEFieldNumber = 15;
  private:
  const ::blox_test::Sequence::StartWaitProfile& _internal_start_profile() const;
  public:
  const ::blox_test::Sequence::StartWaitProfile& start_profile() const;
  ::blox_test::Sequence::StartWaitProfile* release_start_profile();
  ::blox_test::Sequence::StartWaitProfile* mutable_start_profile();
  void set_allocated_start_profile(::blox_test::Sequence::StartWaitProfile* start_profile);

  // .blox_test.Sequence.StartWaitProfile WAIT_PROFILE = 16;
  bool has_wait_profile() const;
  void clear_wait_profile();
  static const int kWAITPROFILEFieldNumber = 16;
  private:
  const ::blox_test::Sequence::StartWaitProfile& _internal_wait_profile() const;
  public:
  const ::blox_test::Sequence::StartWaitProfile& wait_profile() const;
  ::blox_test::Sequence::StartWaitProfile* release_wait_profile();
  ::blox_test::Sequence::StartWaitProfile* mutable_wait_profile();
  void set_allocated_wait_profile(::blox_test::Sequence::StartWaitProfile* wait_profile);

  // .blox_test.Sequence.StartWaitSequence START_SEQUENCE = 17;
  bool has_start_sequence() const;
  void clear_start_sequence();
  static const int kSTARTSEQUENCEFieldNumber = 17;
  private:
  const ::blox_test::Sequence::StartWaitSequence& _internal_start_sequence() const;
  public:
  const ::blox_test::Sequence::StartWaitSequence& start_sequence() const;
  ::blox_test::Sequence::StartWaitSequence* release_start_sequence();
  ::blox_test::Sequence::StartWaitSequence* mutable_start_sequence();
  void set_allocated_start_sequence(::blox_test::Sequence::StartWaitSequence* start_sequence);

  // .blox_test.Sequence.StartWaitSequence WAIT_SEQUENCE = 18;
  bool has_wait_sequence() const;
  void clear_wait_sequence();
  static const int kWAITSEQUENCEFieldNumber = 18;
  private:
  const ::blox_test::Sequence::StartWaitSequence& _internal_wait_sequence() const;
  public:
  const ::blox_test::Sequence::StartWaitSequence& wait_sequence() const;
  ::blox_test::Sequence::StartWaitSequence* release_wait_sequence();
  ::blox_test::Sequence::StartWaitSequence* mutable_wait_sequence();
  void set_allocated_wait_sequence(::blox_test::Sequence::StartWaitSequence* wait_sequence);

  void clear_instruction_oneof();
  InstructionOneofCase instruction_oneof_case() const;
  // @@protoc_insertion_point(class_scope:blox_test.Sequence.Instruction)
 private:
  void set_has_restart();
  void set_has_enable();
  void set_has_disable();
  void set_has_wait_duration();
  void set_has_wait_until();
  void set_has_wait_temperature_between();
  void set_has_wait_temperature_above();
  void set_has_wait_temperature_below();
  void set_has_set_setpoint();
  void set_has_wait_setpoint();
  void set_has_set_digital();
  void set_has_wait_digital();
  void set_has_set_pwm();
  void set_has_wait_pwm();
  void set_has_start_profile();
  void set_has_wait_profile();
  void set_has_start_sequence();
  void set_has_wait_sequence();

  inline bool has_instruction_oneof() const;
  inline void clear_has_instruction_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InstructionOneofUnion {
    InstructionOneofUnion() {}
    ::blox_test::Sequence::Restart* restart_;
    ::blox_test::Sequence::EnableDisable* enable_;
    ::blox_test::Sequence::EnableDisable* disable_;
    ::blox_test::Sequence::WaitDuration* wait_duration_;
    ::blox_test::Sequence::WaitUntil* wait_until_;
    ::blox_test::Sequence::WaitTemperature* wait_temperature_between_;
    ::blox_test::Sequence::WaitTemperatureBoundary* wait_temperature_above_;
    ::blox_test::Sequence::WaitTemperatureBoundary* wait_temperature_below_;
    ::blox_test::Sequence::SetSetpoint* set_setpoint_;
    ::blox_test::Sequence::WaitSetpoint* wait_setpoint_;
    ::blox_test::Sequence::SetDigital* set_digital_;
    ::blox_test::Sequence::WaitDigital* wait_digital_;
    ::blox_test::Sequence::SetPwm* set_pwm_;
    ::blox_test::Sequence::WaitPwm* wait_pwm_;
    ::blox_test::Sequence::StartWaitProfile* start_profile_;
    ::blox_test::Sequence::StartWaitProfile* wait_profile_;
    ::blox_test::Sequence::StartWaitSequence* start_sequence_;
    ::blox_test::Sequence::StartWaitSequence* wait_sequence_;
  } instruction_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstructionReset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.InstructionReset) */ {
 public:
  InstructionReset();
  virtual ~InstructionReset();

  InstructionReset(const InstructionReset& from);

  inline InstructionReset& operator=(const InstructionReset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstructionReset(InstructionReset&& from) noexcept
    : InstructionReset() {
    *this = ::std::move(from);
  }

  inline InstructionReset& operator=(InstructionReset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstructionReset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstructionReset* internal_default_instance() {
    return reinterpret_cast<const InstructionReset*>(
               &_InstructionReset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(InstructionReset* other);
  friend void swap(InstructionReset& a, InstructionReset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstructionReset* New() const final {
    return CreateMaybeMessage<InstructionReset>(NULL);
  }

  InstructionReset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstructionReset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InstructionReset& from);
  void MergeFrom(const InstructionReset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstructionReset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 activeInstruction = 1 [(.nanopb) = {
  void clear_activeinstruction();
  static const int kActiveInstructionFieldNumber = 1;
  ::google::protobuf::uint32 activeinstruction() const;
  void set_activeinstruction(::google::protobuf::uint32 value);

  // uint32 activeInstructionStartedAt = 2 [(.nanopb) = {
  void clear_activeinstructionstartedat();
  static const int kActiveInstructionStartedAtFieldNumber = 2;
  ::google::protobuf::uint32 activeinstructionstartedat() const;
  void set_activeinstructionstartedat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.InstructionReset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 activeinstruction_;
  ::google::protobuf::uint32 activeinstructionstartedat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox_test.Sequence.Instruction instructions = 2;
  int instructions_size() const;
  void clear_instructions();
  static const int kInstructionsFieldNumber = 2;
  ::blox_test::Sequence::Instruction* mutable_instructions(int index);
  ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >*
      mutable_instructions();
  const ::blox_test::Sequence::Instruction& instructions(int index) const;
  ::blox_test::Sequence::Instruction* add_instructions();
  const ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >&
      instructions() const;

  // bool enabled = 1 [(.brewblox.field) = {
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // bool overrideState = 3;
  void clear_overridestate();
  static const int kOverrideStateFieldNumber = 3;
  bool overridestate() const;
  void set_overridestate(bool value);

  // uint32 activeInstruction = 4 [(.nanopb) = {
  void clear_activeinstruction();
  static const int kActiveInstructionFieldNumber = 4;
  ::google::protobuf::uint32 activeinstruction() const;
  void set_activeinstruction(::google::protobuf::uint32 value);

  // uint32 activeInstructionStartedAt = 5 [(.nanopb) = {
  void clear_activeinstructionstartedat();
  static const int kActiveInstructionStartedAtFieldNumber = 5;
  ::google::protobuf::uint32 activeinstructionstartedat() const;
  void set_activeinstructionstartedat(::google::protobuf::uint32 value);

  // uint32 disabledAt = 6 [(.nanopb) = {
  void clear_disabledat();
  static const int kDisabledAtFieldNumber = 6;
  ::google::protobuf::uint32 disabledat() const;
  void set_disabledat(::google::protobuf::uint32 value);

  // uint32 disabledDuration = 7 [(.nanopb) = {
  void clear_disabledduration();
  static const int kDisabledDurationFieldNumber = 7;
  ::google::protobuf::uint32 disabledduration() const;
  void set_disabledduration(::google::protobuf::uint32 value);

  // .blox_test.Sequence.SequenceStatus status = 8 [(.brewblox.field) = {
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::blox_test::Sequence::SequenceStatus status() const;
  void set_status(::blox_test::Sequence::SequenceStatus value);

  // .blox_test.Sequence.SequenceError error = 9 [(.brewblox.field) = {
  void clear_error();
  static const int kErrorFieldNumber = 9;
  ::blox_test::Sequence::SequenceError error() const;
  void set_error(::blox_test::Sequence::SequenceError value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction > instructions_;
  bool enabled_;
  bool overridestate_;
  ::google::protobuf::uint32 activeinstruction_;
  ::google::protobuf::uint32 activeinstructionstartedat_;
  ::google::protobuf::uint32 disabledat_;
  ::google::protobuf::uint32 disabledduration_;
  int status_;
  int error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Restart

// -------------------------------------------------------------------

// EnableDisable

// uint32 target = 1 [(.nanopb) = {
inline void EnableDisable::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 EnableDisable::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.EnableDisable.target)
  return target_;
}
inline void EnableDisable::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.EnableDisable.target)
}

// -------------------------------------------------------------------

// WaitDuration

// uint32 duration = 1 [(.nanopb) = {
inline void WaitDuration::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 WaitDuration::duration() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitDuration.duration)
  return duration_;
}
inline void WaitDuration::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitDuration.duration)
}

// -------------------------------------------------------------------

// WaitUntil

// uint32 time = 1 [(.nanopb) = {
inline void WaitUntil::clear_time() {
  time_ = 0u;
}
inline ::google::protobuf::uint32 WaitUntil::time() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitUntil.time)
  return time_;
}
inline void WaitUntil::set_time(::google::protobuf::uint32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitUntil.time)
}

// -------------------------------------------------------------------

// WaitTemperature

// uint32 target = 1 [(.nanopb) = {
inline void WaitTemperature::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitTemperature::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperature.target)
  return target_;
}
inline void WaitTemperature::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperature.target)
}

// sint32 lower = 2 [(.nanopb) = {
inline void WaitTemperature::clear_lower() {
  lower_ = 0;
}
inline ::google::protobuf::int32 WaitTemperature::lower() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperature.lower)
  return lower_;
}
inline void WaitTemperature::set_lower(::google::protobuf::int32 value) {
  
  lower_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperature.lower)
}

// sint32 upper = 3 [(.nanopb) = {
inline void WaitTemperature::clear_upper() {
  upper_ = 0;
}
inline ::google::protobuf::int32 WaitTemperature::upper() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperature.upper)
  return upper_;
}
inline void WaitTemperature::set_upper(::google::protobuf::int32 value) {
  
  upper_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperature.upper)
}

// -------------------------------------------------------------------

// WaitTemperatureBoundary

// uint32 target = 1 [(.nanopb) = {
inline void WaitTemperatureBoundary::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitTemperatureBoundary::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperatureBoundary.target)
  return target_;
}
inline void WaitTemperatureBoundary::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperatureBoundary.target)
}

// sint32 value = 2 [(.nanopb) = {
inline void WaitTemperatureBoundary::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 WaitTemperatureBoundary::value() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperatureBoundary.value)
  return value_;
}
inline void WaitTemperatureBoundary::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperatureBoundary.value)
}

// -------------------------------------------------------------------

// SetSetpoint

// uint32 target = 1 [(.nanopb) = {
inline void SetSetpoint::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 SetSetpoint::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetSetpoint.target)
  return target_;
}
inline void SetSetpoint::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetSetpoint.target)
}

// sint32 setting = 2 [(.nanopb) = {
inline void SetSetpoint::clear_setting() {
  setting_ = 0;
}
inline ::google::protobuf::int32 SetSetpoint::setting() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetSetpoint.setting)
  return setting_;
}
inline void SetSetpoint::set_setting(::google::protobuf::int32 value) {
  
  setting_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetSetpoint.setting)
}

// -------------------------------------------------------------------

// WaitSetpoint

// uint32 target = 1 [(.nanopb) = {
inline void WaitSetpoint::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitSetpoint::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitSetpoint.target)
  return target_;
}
inline void WaitSetpoint::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitSetpoint.target)
}

// sint32 precision = 2 [(.nanopb) = {
inline void WaitSetpoint::clear_precision() {
  precision_ = 0;
}
inline ::google::protobuf::int32 WaitSetpoint::precision() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitSetpoint.precision)
  return precision_;
}
inline void WaitSetpoint::set_precision(::google::protobuf::int32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitSetpoint.precision)
}

// -------------------------------------------------------------------

// SetDigital

// uint32 target = 1 [(.nanopb) = {
inline void SetDigital::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 SetDigital::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetDigital.target)
  return target_;
}
inline void SetDigital::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetDigital.target)
}

// .blox_test.IoArray.DigitalState setting = 2;
inline void SetDigital::clear_setting() {
  setting_ = 0;
}
inline ::blox_test::IoArray::DigitalState SetDigital::setting() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetDigital.setting)
  return static_cast< ::blox_test::IoArray::DigitalState >(setting_);
}
inline void SetDigital::set_setting(::blox_test::IoArray::DigitalState value) {
  
  setting_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetDigital.setting)
}

// -------------------------------------------------------------------

// WaitDigital

// uint32 target = 1 [(.nanopb) = {
inline void WaitDigital::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitDigital::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitDigital.target)
  return target_;
}
inline void WaitDigital::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitDigital.target)
}

// -------------------------------------------------------------------

// SetPwm

// uint32 target = 1 [(.nanopb) = {
inline void SetPwm::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 SetPwm::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetPwm.target)
  return target_;
}
inline void SetPwm::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetPwm.target)
}

// sint32 setting = 2 [(.nanopb) = {
inline void SetPwm::clear_setting() {
  setting_ = 0;
}
inline ::google::protobuf::int32 SetPwm::setting() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetPwm.setting)
  return setting_;
}
inline void SetPwm::set_setting(::google::protobuf::int32 value) {
  
  setting_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetPwm.setting)
}

// -------------------------------------------------------------------

// WaitPwm

// uint32 target = 1 [(.nanopb) = {
inline void WaitPwm::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitPwm::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitPwm.target)
  return target_;
}
inline void WaitPwm::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitPwm.target)
}

// sint32 precision = 2 [(.nanopb) = {
inline void WaitPwm::clear_precision() {
  precision_ = 0;
}
inline ::google::protobuf::int32 WaitPwm::precision() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitPwm.precision)
  return precision_;
}
inline void WaitPwm::set_precision(::google::protobuf::int32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitPwm.precision)
}

// -------------------------------------------------------------------

// StartWaitProfile

// uint32 target = 1 [(.nanopb) = {
inline void StartWaitProfile::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 StartWaitProfile::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.StartWaitProfile.target)
  return target_;
}
inline void StartWaitProfile::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.StartWaitProfile.target)
}

// -------------------------------------------------------------------

// StartWaitSequence

// uint32 target = 1 [(.nanopb) = {
inline void StartWaitSequence::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 StartWaitSequence::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.StartWaitSequence.target)
  return target_;
}
inline void StartWaitSequence::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.StartWaitSequence.target)
}

// -------------------------------------------------------------------

// Instruction

// .blox_test.Sequence.Restart RESTART = 1;
inline bool Instruction::has_restart() const {
  return instruction_oneof_case() == kRESTART;
}
inline void Instruction::set_has_restart() {
  _oneof_case_[0] = kRESTART;
}
inline void Instruction::clear_restart() {
  if (has_restart()) {
    delete instruction_oneof_.restart_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::Restart& Instruction::_internal_restart() const {
  return *instruction_oneof_.restart_;
}
inline ::blox_test::Sequence::Restart* Instruction::release_restart() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.RESTART)
  if (has_restart()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::Restart* temp = instruction_oneof_.restart_;
    instruction_oneof_.restart_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::Restart& Instruction::restart() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.RESTART)
  return has_restart()
      ? *instruction_oneof_.restart_
      : *reinterpret_cast< ::blox_test::Sequence::Restart*>(&::blox_test::Sequence::_Restart_default_instance_);
}
inline ::blox_test::Sequence::Restart* Instruction::mutable_restart() {
  if (!has_restart()) {
    clear_instruction_oneof();
    set_has_restart();
    instruction_oneof_.restart_ = CreateMaybeMessage< ::blox_test::Sequence::Restart >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.RESTART)
  return instruction_oneof_.restart_;
}

// .blox_test.Sequence.EnableDisable ENABLE = 2;
inline bool Instruction::has_enable() const {
  return instruction_oneof_case() == kENABLE;
}
inline void Instruction::set_has_enable() {
  _oneof_case_[0] = kENABLE;
}
inline void Instruction::clear_enable() {
  if (has_enable()) {
    delete instruction_oneof_.enable_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::_internal_enable() const {
  return *instruction_oneof_.enable_;
}
inline ::blox_test::Sequence::EnableDisable* Instruction::release_enable() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.ENABLE)
  if (has_enable()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::EnableDisable* temp = instruction_oneof_.enable_;
    instruction_oneof_.enable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::enable() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.ENABLE)
  return has_enable()
      ? *instruction_oneof_.enable_
      : *reinterpret_cast< ::blox_test::Sequence::EnableDisable*>(&::blox_test::Sequence::_EnableDisable_default_instance_);
}
inline ::blox_test::Sequence::EnableDisable* Instruction::mutable_enable() {
  if (!has_enable()) {
    clear_instruction_oneof();
    set_has_enable();
    instruction_oneof_.enable_ = CreateMaybeMessage< ::blox_test::Sequence::EnableDisable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.ENABLE)
  return instruction_oneof_.enable_;
}

// .blox_test.Sequence.EnableDisable DISABLE = 3;
inline bool Instruction::has_disable() const {
  return instruction_oneof_case() == kDISABLE;
}
inline void Instruction::set_has_disable() {
  _oneof_case_[0] = kDISABLE;
}
inline void Instruction::clear_disable() {
  if (has_disable()) {
    delete instruction_oneof_.disable_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::_internal_disable() const {
  return *instruction_oneof_.disable_;
}
inline ::blox_test::Sequence::EnableDisable* Instruction::release_disable() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.DISABLE)
  if (has_disable()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::EnableDisable* temp = instruction_oneof_.disable_;
    instruction_oneof_.disable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::disable() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.DISABLE)
  return has_disable()
      ? *instruction_oneof_.disable_
      : *reinterpret_cast< ::blox_test::Sequence::EnableDisable*>(&::blox_test::Sequence::_EnableDisable_default_instance_);
}
inline ::blox_test::Sequence::EnableDisable* Instruction::mutable_disable() {
  if (!has_disable()) {
    clear_instruction_oneof();
    set_has_disable();
    instruction_oneof_.disable_ = CreateMaybeMessage< ::blox_test::Sequence::EnableDisable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.DISABLE)
  return instruction_oneof_.disable_;
}

// .blox_test.Sequence.WaitDuration WAIT_DURATION = 4;
inline bool Instruction::has_wait_duration() const {
  return instruction_oneof_case() == kWAITDURATION;
}
inline void Instruction::set_has_wait_duration() {
  _oneof_case_[0] = kWAITDURATION;
}
inline void Instruction::clear_wait_duration() {
  if (has_wait_duration()) {
    delete instruction_oneof_.wait_duration_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitDuration& Instruction::_internal_wait_duration() const {
  return *instruction_oneof_.wait_duration_;
}
inline ::blox_test::Sequence::WaitDuration* Instruction::release_wait_duration() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_DURATION)
  if (has_wait_duration()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitDuration* temp = instruction_oneof_.wait_duration_;
    instruction_oneof_.wait_duration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitDuration& Instruction::wait_duration() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_DURATION)
  return has_wait_duration()
      ? *instruction_oneof_.wait_duration_
      : *reinterpret_cast< ::blox_test::Sequence::WaitDuration*>(&::blox_test::Sequence::_WaitDuration_default_instance_);
}
inline ::blox_test::Sequence::WaitDuration* Instruction::mutable_wait_duration() {
  if (!has_wait_duration()) {
    clear_instruction_oneof();
    set_has_wait_duration();
    instruction_oneof_.wait_duration_ = CreateMaybeMessage< ::blox_test::Sequence::WaitDuration >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_DURATION)
  return instruction_oneof_.wait_duration_;
}

// .blox_test.Sequence.WaitUntil WAIT_UNTIL = 5;
inline bool Instruction::has_wait_until() const {
  return instruction_oneof_case() == kWAITUNTIL;
}
inline void Instruction::set_has_wait_until() {
  _oneof_case_[0] = kWAITUNTIL;
}
inline void Instruction::clear_wait_until() {
  if (has_wait_until()) {
    delete instruction_oneof_.wait_until_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitUntil& Instruction::_internal_wait_until() const {
  return *instruction_oneof_.wait_until_;
}
inline ::blox_test::Sequence::WaitUntil* Instruction::release_wait_until() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_UNTIL)
  if (has_wait_until()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitUntil* temp = instruction_oneof_.wait_until_;
    instruction_oneof_.wait_until_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitUntil& Instruction::wait_until() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_UNTIL)
  return has_wait_until()
      ? *instruction_oneof_.wait_until_
      : *reinterpret_cast< ::blox_test::Sequence::WaitUntil*>(&::blox_test::Sequence::_WaitUntil_default_instance_);
}
inline ::blox_test::Sequence::WaitUntil* Instruction::mutable_wait_until() {
  if (!has_wait_until()) {
    clear_instruction_oneof();
    set_has_wait_until();
    instruction_oneof_.wait_until_ = CreateMaybeMessage< ::blox_test::Sequence::WaitUntil >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_UNTIL)
  return instruction_oneof_.wait_until_;
}

// .blox_test.Sequence.WaitTemperature WAIT_TEMPERATURE_BETWEEN = 6;
inline bool Instruction::has_wait_temperature_between() const {
  return instruction_oneof_case() == kWAITTEMPERATUREBETWEEN;
}
inline void Instruction::set_has_wait_temperature_between() {
  _oneof_case_[0] = kWAITTEMPERATUREBETWEEN;
}
inline void Instruction::clear_wait_temperature_between() {
  if (has_wait_temperature_between()) {
    delete instruction_oneof_.wait_temperature_between_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitTemperature& Instruction::_internal_wait_temperature_between() const {
  return *instruction_oneof_.wait_temperature_between_;
}
inline ::blox_test::Sequence::WaitTemperature* Instruction::release_wait_temperature_between() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_BETWEEN)
  if (has_wait_temperature_between()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitTemperature* temp = instruction_oneof_.wait_temperature_between_;
    instruction_oneof_.wait_temperature_between_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitTemperature& Instruction::wait_temperature_between() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_BETWEEN)
  return has_wait_temperature_between()
      ? *instruction_oneof_.wait_temperature_between_
      : *reinterpret_cast< ::blox_test::Sequence::WaitTemperature*>(&::blox_test::Sequence::_WaitTemperature_default_instance_);
}
inline ::blox_test::Sequence::WaitTemperature* Instruction::mutable_wait_temperature_between() {
  if (!has_wait_temperature_between()) {
    clear_instruction_oneof();
    set_has_wait_temperature_between();
    instruction_oneof_.wait_temperature_between_ = CreateMaybeMessage< ::blox_test::Sequence::WaitTemperature >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_BETWEEN)
  return instruction_oneof_.wait_temperature_between_;
}

// .blox_test.Sequence.WaitTemperatureBoundary WAIT_TEMPERATURE_ABOVE = 7;
inline bool Instruction::has_wait_temperature_above() const {
  return instruction_oneof_case() == kWAITTEMPERATUREABOVE;
}
inline void Instruction::set_has_wait_temperature_above() {
  _oneof_case_[0] = kWAITTEMPERATUREABOVE;
}
inline void Instruction::clear_wait_temperature_above() {
  if (has_wait_temperature_above()) {
    delete instruction_oneof_.wait_temperature_above_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::_internal_wait_temperature_above() const {
  return *instruction_oneof_.wait_temperature_above_;
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::release_wait_temperature_above() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_ABOVE)
  if (has_wait_temperature_above()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitTemperatureBoundary* temp = instruction_oneof_.wait_temperature_above_;
    instruction_oneof_.wait_temperature_above_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::wait_temperature_above() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_ABOVE)
  return has_wait_temperature_above()
      ? *instruction_oneof_.wait_temperature_above_
      : *reinterpret_cast< ::blox_test::Sequence::WaitTemperatureBoundary*>(&::blox_test::Sequence::_WaitTemperatureBoundary_default_instance_);
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::mutable_wait_temperature_above() {
  if (!has_wait_temperature_above()) {
    clear_instruction_oneof();
    set_has_wait_temperature_above();
    instruction_oneof_.wait_temperature_above_ = CreateMaybeMessage< ::blox_test::Sequence::WaitTemperatureBoundary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_ABOVE)
  return instruction_oneof_.wait_temperature_above_;
}

// .blox_test.Sequence.WaitTemperatureBoundary WAIT_TEMPERATURE_BELOW = 8;
inline bool Instruction::has_wait_temperature_below() const {
  return instruction_oneof_case() == kWAITTEMPERATUREBELOW;
}
inline void Instruction::set_has_wait_temperature_below() {
  _oneof_case_[0] = kWAITTEMPERATUREBELOW;
}
inline void Instruction::clear_wait_temperature_below() {
  if (has_wait_temperature_below()) {
    delete instruction_oneof_.wait_temperature_below_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::_internal_wait_temperature_below() const {
  return *instruction_oneof_.wait_temperature_below_;
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::release_wait_temperature_below() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_BELOW)
  if (has_wait_temperature_below()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitTemperatureBoundary* temp = instruction_oneof_.wait_temperature_below_;
    instruction_oneof_.wait_temperature_below_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::wait_temperature_below() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_BELOW)
  return has_wait_temperature_below()
      ? *instruction_oneof_.wait_temperature_below_
      : *reinterpret_cast< ::blox_test::Sequence::WaitTemperatureBoundary*>(&::blox_test::Sequence::_WaitTemperatureBoundary_default_instance_);
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::mutable_wait_temperature_below() {
  if (!has_wait_temperature_below()) {
    clear_instruction_oneof();
    set_has_wait_temperature_below();
    instruction_oneof_.wait_temperature_below_ = CreateMaybeMessage< ::blox_test::Sequence::WaitTemperatureBoundary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_TEMPERATURE_BELOW)
  return instruction_oneof_.wait_temperature_below_;
}

// .blox_test.Sequence.SetSetpoint SET_SETPOINT = 9;
inline bool Instruction::has_set_setpoint() const {
  return instruction_oneof_case() == kSETSETPOINT;
}
inline void Instruction::set_has_set_setpoint() {
  _oneof_case_[0] = kSETSETPOINT;
}
inline void Instruction::clear_set_setpoint() {
  if (has_set_setpoint()) {
    delete instruction_oneof_.set_setpoint_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::SetSetpoint& Instruction::_internal_set_setpoint() const {
  return *instruction_oneof_.set_setpoint_;
}
inline ::blox_test::Sequence::SetSetpoint* Instruction::release_set_setpoint() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.SET_SETPOINT)
  if (has_set_setpoint()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::SetSetpoint* temp = instruction_oneof_.set_setpoint_;
    instruction_oneof_.set_setpoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::SetSetpoint& Instruction::set_setpoint() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.SET_SETPOINT)
  return has_set_setpoint()
      ? *instruction_oneof_.set_setpoint_
      : *reinterpret_cast< ::blox_test::Sequence::SetSetpoint*>(&::blox_test::Sequence::_SetSetpoint_default_instance_);
}
inline ::blox_test::Sequence::SetSetpoint* Instruction::mutable_set_setpoint() {
  if (!has_set_setpoint()) {
    clear_instruction_oneof();
    set_has_set_setpoint();
    instruction_oneof_.set_setpoint_ = CreateMaybeMessage< ::blox_test::Sequence::SetSetpoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.SET_SETPOINT)
  return instruction_oneof_.set_setpoint_;
}

// .blox_test.Sequence.WaitSetpoint WAIT_SETPOINT = 10;
inline bool Instruction::has_wait_setpoint() const {
  return instruction_oneof_case() == kWAITSETPOINT;
}
inline void Instruction::set_has_wait_setpoint() {
  _oneof_case_[0] = kWAITSETPOINT;
}
inline void Instruction::clear_wait_setpoint() {
  if (has_wait_setpoint()) {
    delete instruction_oneof_.wait_setpoint_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitSetpoint& Instruction::_internal_wait_setpoint() const {
  return *instruction_oneof_.wait_setpoint_;
}
inline ::blox_test::Sequence::WaitSetpoint* Instruction::release_wait_setpoint() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_SETPOINT)
  if (has_wait_setpoint()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitSetpoint* temp = instruction_oneof_.wait_setpoint_;
    instruction_oneof_.wait_setpoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitSetpoint& Instruction::wait_setpoint() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_SETPOINT)
  return has_wait_setpoint()
      ? *instruction_oneof_.wait_setpoint_
      : *reinterpret_cast< ::blox_test::Sequence::WaitSetpoint*>(&::blox_test::Sequence::_WaitSetpoint_default_instance_);
}
inline ::blox_test::Sequence::WaitSetpoint* Instruction::mutable_wait_setpoint() {
  if (!has_wait_setpoint()) {
    clear_instruction_oneof();
    set_has_wait_setpoint();
    instruction_oneof_.wait_setpoint_ = CreateMaybeMessage< ::blox_test::Sequence::WaitSetpoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_SETPOINT)
  return instruction_oneof_.wait_setpoint_;
}

// .blox_test.Sequence.SetDigital SET_DIGITAL = 11;
inline bool Instruction::has_set_digital() const {
  return instruction_oneof_case() == kSETDIGITAL;
}
inline void Instruction::set_has_set_digital() {
  _oneof_case_[0] = kSETDIGITAL;
}
inline void Instruction::clear_set_digital() {
  if (has_set_digital()) {
    delete instruction_oneof_.set_digital_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::SetDigital& Instruction::_internal_set_digital() const {
  return *instruction_oneof_.set_digital_;
}
inline ::blox_test::Sequence::SetDigital* Instruction::release_set_digital() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.SET_DIGITAL)
  if (has_set_digital()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::SetDigital* temp = instruction_oneof_.set_digital_;
    instruction_oneof_.set_digital_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::SetDigital& Instruction::set_digital() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.SET_DIGITAL)
  return has_set_digital()
      ? *instruction_oneof_.set_digital_
      : *reinterpret_cast< ::blox_test::Sequence::SetDigital*>(&::blox_test::Sequence::_SetDigital_default_instance_);
}
inline ::blox_test::Sequence::SetDigital* Instruction::mutable_set_digital() {
  if (!has_set_digital()) {
    clear_instruction_oneof();
    set_has_set_digital();
    instruction_oneof_.set_digital_ = CreateMaybeMessage< ::blox_test::Sequence::SetDigital >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.SET_DIGITAL)
  return instruction_oneof_.set_digital_;
}

// .blox_test.Sequence.WaitDigital WAIT_DIGITAL = 12;
inline bool Instruction::has_wait_digital() const {
  return instruction_oneof_case() == kWAITDIGITAL;
}
inline void Instruction::set_has_wait_digital() {
  _oneof_case_[0] = kWAITDIGITAL;
}
inline void Instruction::clear_wait_digital() {
  if (has_wait_digital()) {
    delete instruction_oneof_.wait_digital_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitDigital& Instruction::_internal_wait_digital() const {
  return *instruction_oneof_.wait_digital_;
}
inline ::blox_test::Sequence::WaitDigital* Instruction::release_wait_digital() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_DIGITAL)
  if (has_wait_digital()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitDigital* temp = instruction_oneof_.wait_digital_;
    instruction_oneof_.wait_digital_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitDigital& Instruction::wait_digital() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_DIGITAL)
  return has_wait_digital()
      ? *instruction_oneof_.wait_digital_
      : *reinterpret_cast< ::blox_test::Sequence::WaitDigital*>(&::blox_test::Sequence::_WaitDigital_default_instance_);
}
inline ::blox_test::Sequence::WaitDigital* Instruction::mutable_wait_digital() {
  if (!has_wait_digital()) {
    clear_instruction_oneof();
    set_has_wait_digital();
    instruction_oneof_.wait_digital_ = CreateMaybeMessage< ::blox_test::Sequence::WaitDigital >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_DIGITAL)
  return instruction_oneof_.wait_digital_;
}

// .blox_test.Sequence.SetPwm SET_PWM = 13;
inline bool Instruction::has_set_pwm() const {
  return instruction_oneof_case() == kSETPWM;
}
inline void Instruction::set_has_set_pwm() {
  _oneof_case_[0] = kSETPWM;
}
inline void Instruction::clear_set_pwm() {
  if (has_set_pwm()) {
    delete instruction_oneof_.set_pwm_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::SetPwm& Instruction::_internal_set_pwm() const {
  return *instruction_oneof_.set_pwm_;
}
inline ::blox_test::Sequence::SetPwm* Instruction::release_set_pwm() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.SET_PWM)
  if (has_set_pwm()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::SetPwm* temp = instruction_oneof_.set_pwm_;
    instruction_oneof_.set_pwm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::SetPwm& Instruction::set_pwm() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.SET_PWM)
  return has_set_pwm()
      ? *instruction_oneof_.set_pwm_
      : *reinterpret_cast< ::blox_test::Sequence::SetPwm*>(&::blox_test::Sequence::_SetPwm_default_instance_);
}
inline ::blox_test::Sequence::SetPwm* Instruction::mutable_set_pwm() {
  if (!has_set_pwm()) {
    clear_instruction_oneof();
    set_has_set_pwm();
    instruction_oneof_.set_pwm_ = CreateMaybeMessage< ::blox_test::Sequence::SetPwm >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.SET_PWM)
  return instruction_oneof_.set_pwm_;
}

// .blox_test.Sequence.WaitPwm WAIT_PWM = 14;
inline bool Instruction::has_wait_pwm() const {
  return instruction_oneof_case() == kWAITPWM;
}
inline void Instruction::set_has_wait_pwm() {
  _oneof_case_[0] = kWAITPWM;
}
inline void Instruction::clear_wait_pwm() {
  if (has_wait_pwm()) {
    delete instruction_oneof_.wait_pwm_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitPwm& Instruction::_internal_wait_pwm() const {
  return *instruction_oneof_.wait_pwm_;
}
inline ::blox_test::Sequence::WaitPwm* Instruction::release_wait_pwm() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_PWM)
  if (has_wait_pwm()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitPwm* temp = instruction_oneof_.wait_pwm_;
    instruction_oneof_.wait_pwm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitPwm& Instruction::wait_pwm() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_PWM)
  return has_wait_pwm()
      ? *instruction_oneof_.wait_pwm_
      : *reinterpret_cast< ::blox_test::Sequence::WaitPwm*>(&::blox_test::Sequence::_WaitPwm_default_instance_);
}
inline ::blox_test::Sequence::WaitPwm* Instruction::mutable_wait_pwm() {
  if (!has_wait_pwm()) {
    clear_instruction_oneof();
    set_has_wait_pwm();
    instruction_oneof_.wait_pwm_ = CreateMaybeMessage< ::blox_test::Sequence::WaitPwm >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_PWM)
  return instruction_oneof_.wait_pwm_;
}

// .blox_test.Sequence.StartWaitProfile START_PROFILE = 15;
inline bool Instruction::has_start_profile() const {
  return instruction_oneof_case() == kSTARTPROFILE;
}
inline void Instruction::set_has_start_profile() {
  _oneof_case_[0] = kSTARTPROFILE;
}
inline void Instruction::clear_start_profile() {
  if (has_start_profile()) {
    delete instruction_oneof_.start_profile_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::_internal_start_profile() const {
  return *instruction_oneof_.start_profile_;
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::release_start_profile() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.START_PROFILE)
  if (has_start_profile()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitProfile* temp = instruction_oneof_.start_profile_;
    instruction_oneof_.start_profile_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::start_profile() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.START_PROFILE)
  return has_start_profile()
      ? *instruction_oneof_.start_profile_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitProfile*>(&::blox_test::Sequence::_StartWaitProfile_default_instance_);
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::mutable_start_profile() {
  if (!has_start_profile()) {
    clear_instruction_oneof();
    set_has_start_profile();
    instruction_oneof_.start_profile_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitProfile >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.START_PROFILE)
  return instruction_oneof_.start_profile_;
}

// .blox_test.Sequence.StartWaitProfile WAIT_PROFILE = 16;
inline bool Instruction::has_wait_profile() const {
  return instruction_oneof_case() == kWAITPROFILE;
}
inline void Instruction::set_has_wait_profile() {
  _oneof_case_[0] = kWAITPROFILE;
}
inline void Instruction::clear_wait_profile() {
  if (has_wait_profile()) {
    delete instruction_oneof_.wait_profile_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::_internal_wait_profile() const {
  return *instruction_oneof_.wait_profile_;
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::release_wait_profile() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_PROFILE)
  if (has_wait_profile()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitProfile* temp = instruction_oneof_.wait_profile_;
    instruction_oneof_.wait_profile_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::wait_profile() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_PROFILE)
  return has_wait_profile()
      ? *instruction_oneof_.wait_profile_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitProfile*>(&::blox_test::Sequence::_StartWaitProfile_default_instance_);
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::mutable_wait_profile() {
  if (!has_wait_profile()) {
    clear_instruction_oneof();
    set_has_wait_profile();
    instruction_oneof_.wait_profile_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitProfile >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_PROFILE)
  return instruction_oneof_.wait_profile_;
}

// .blox_test.Sequence.StartWaitSequence START_SEQUENCE = 17;
inline bool Instruction::has_start_sequence() const {
  return instruction_oneof_case() == kSTARTSEQUENCE;
}
inline void Instruction::set_has_start_sequence() {
  _oneof_case_[0] = kSTARTSEQUENCE;
}
inline void Instruction::clear_start_sequence() {
  if (has_start_sequence()) {
    delete instruction_oneof_.start_sequence_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::_internal_start_sequence() const {
  return *instruction_oneof_.start_sequence_;
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::release_start_sequence() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.START_SEQUENCE)
  if (has_start_sequence()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitSequence* temp = instruction_oneof_.start_sequence_;
    instruction_oneof_.start_sequence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::start_sequence() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.START_SEQUENCE)
  return has_start_sequence()
      ? *instruction_oneof_.start_sequence_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitSequence*>(&::blox_test::Sequence::_StartWaitSequence_default_instance_);
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::mutable_start_sequence() {
  if (!has_start_sequence()) {
    clear_instruction_oneof();
    set_has_start_sequence();
    instruction_oneof_.start_sequence_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitSequence >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.START_SEQUENCE)
  return instruction_oneof_.start_sequence_;
}

// .blox_test.Sequence.StartWaitSequence WAIT_SEQUENCE = 18;
inline bool Instruction::has_wait_sequence() const {
  return instruction_oneof_case() == kWAITSEQUENCE;
}
inline void Instruction::set_has_wait_sequence() {
  _oneof_case_[0] = kWAITSEQUENCE;
}
inline void Instruction::clear_wait_sequence() {
  if (has_wait_sequence()) {
    delete instruction_oneof_.wait_sequence_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::_internal_wait_sequence() const {
  return *instruction_oneof_.wait_sequence_;
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::release_wait_sequence() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.WAIT_SEQUENCE)
  if (has_wait_sequence()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitSequence* temp = instruction_oneof_.wait_sequence_;
    instruction_oneof_.wait_sequence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::wait_sequence() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.WAIT_SEQUENCE)
  return has_wait_sequence()
      ? *instruction_oneof_.wait_sequence_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitSequence*>(&::blox_test::Sequence::_StartWaitSequence_default_instance_);
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::mutable_wait_sequence() {
  if (!has_wait_sequence()) {
    clear_instruction_oneof();
    set_has_wait_sequence();
    instruction_oneof_.wait_sequence_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitSequence >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.WAIT_SEQUENCE)
  return instruction_oneof_.wait_sequence_;
}

inline bool Instruction::has_instruction_oneof() const {
  return instruction_oneof_case() != INSTRUCTION_ONEOF_NOT_SET;
}
inline void Instruction::clear_has_instruction_oneof() {
  _oneof_case_[0] = INSTRUCTION_ONEOF_NOT_SET;
}
inline Instruction::InstructionOneofCase Instruction::instruction_oneof_case() const {
  return Instruction::InstructionOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InstructionReset

// uint32 activeInstruction = 1 [(.nanopb) = {
inline void InstructionReset::clear_activeinstruction() {
  activeinstruction_ = 0u;
}
inline ::google::protobuf::uint32 InstructionReset::activeinstruction() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.InstructionReset.activeInstruction)
  return activeinstruction_;
}
inline void InstructionReset::set_activeinstruction(::google::protobuf::uint32 value) {
  
  activeinstruction_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.InstructionReset.activeInstruction)
}

// uint32 activeInstructionStartedAt = 2 [(.nanopb) = {
inline void InstructionReset::clear_activeinstructionstartedat() {
  activeinstructionstartedat_ = 0u;
}
inline ::google::protobuf::uint32 InstructionReset::activeinstructionstartedat() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.InstructionReset.activeInstructionStartedAt)
  return activeinstructionstartedat_;
}
inline void InstructionReset::set_activeinstructionstartedat(::google::protobuf::uint32 value) {
  
  activeinstructionstartedat_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.InstructionReset.activeInstructionStartedAt)
}

// -------------------------------------------------------------------

// Block

// bool enabled = 1 [(.brewblox.field) = {
inline void Block::clear_enabled() {
  enabled_ = false;
}
inline bool Block::enabled() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.enabled)
  return enabled_;
}
inline void Block::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.enabled)
}

// repeated .blox_test.Sequence.Instruction instructions = 2;
inline int Block::instructions_size() const {
  return instructions_.size();
}
inline void Block::clear_instructions() {
  instructions_.Clear();
}
inline ::blox_test::Sequence::Instruction* Block::mutable_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Block.instructions)
  return instructions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >*
Block::mutable_instructions() {
  // @@protoc_insertion_point(field_mutable_list:blox_test.Sequence.Block.instructions)
  return &instructions_;
}
inline const ::blox_test::Sequence::Instruction& Block::instructions(int index) const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.instructions)
  return instructions_.Get(index);
}
inline ::blox_test::Sequence::Instruction* Block::add_instructions() {
  // @@protoc_insertion_point(field_add:blox_test.Sequence.Block.instructions)
  return instructions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >&
Block::instructions() const {
  // @@protoc_insertion_point(field_list:blox_test.Sequence.Block.instructions)
  return instructions_;
}

// bool overrideState = 3;
inline void Block::clear_overridestate() {
  overridestate_ = false;
}
inline bool Block::overridestate() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.overrideState)
  return overridestate_;
}
inline void Block::set_overridestate(bool value) {
  
  overridestate_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.overrideState)
}

// uint32 activeInstruction = 4 [(.nanopb) = {
inline void Block::clear_activeinstruction() {
  activeinstruction_ = 0u;
}
inline ::google::protobuf::uint32 Block::activeinstruction() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.activeInstruction)
  return activeinstruction_;
}
inline void Block::set_activeinstruction(::google::protobuf::uint32 value) {
  
  activeinstruction_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.activeInstruction)
}

// uint32 activeInstructionStartedAt = 5 [(.nanopb) = {
inline void Block::clear_activeinstructionstartedat() {
  activeinstructionstartedat_ = 0u;
}
inline ::google::protobuf::uint32 Block::activeinstructionstartedat() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.activeInstructionStartedAt)
  return activeinstructionstartedat_;
}
inline void Block::set_activeinstructionstartedat(::google::protobuf::uint32 value) {
  
  activeinstructionstartedat_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.activeInstructionStartedAt)
}

// uint32 disabledAt = 6 [(.nanopb) = {
inline void Block::clear_disabledat() {
  disabledat_ = 0u;
}
inline ::google::protobuf::uint32 Block::disabledat() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.disabledAt)
  return disabledat_;
}
inline void Block::set_disabledat(::google::protobuf::uint32 value) {
  
  disabledat_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.disabledAt)
}

// uint32 disabledDuration = 7 [(.nanopb) = {
inline void Block::clear_disabledduration() {
  disabledduration_ = 0u;
}
inline ::google::protobuf::uint32 Block::disabledduration() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.disabledDuration)
  return disabledduration_;
}
inline void Block::set_disabledduration(::google::protobuf::uint32 value) {
  
  disabledduration_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.disabledDuration)
}

// .blox_test.Sequence.SequenceStatus status = 8 [(.brewblox.field) = {
inline void Block::clear_status() {
  status_ = 0;
}
inline ::blox_test::Sequence::SequenceStatus Block::status() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.status)
  return static_cast< ::blox_test::Sequence::SequenceStatus >(status_);
}
inline void Block::set_status(::blox_test::Sequence::SequenceStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.status)
}

// .blox_test.Sequence.SequenceError error = 9 [(.brewblox.field) = {
inline void Block::clear_error() {
  error_ = 0;
}
inline ::blox_test::Sequence::SequenceError Block::error() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.error)
  return static_cast< ::blox_test::Sequence::SequenceError >(error_);
}
inline void Block::set_error(::blox_test::Sequence::SequenceError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Sequence
}  // namespace blox_test

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::blox_test::Sequence::SequenceStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox_test::Sequence::SequenceStatus>() {
  return ::blox_test::Sequence::SequenceStatus_descriptor();
}
template <> struct is_proto_enum< ::blox_test::Sequence::SequenceError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox_test::Sequence::SequenceError>() {
  return ::blox_test::Sequence::SequenceError_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Sequence_5ftest_2eproto
