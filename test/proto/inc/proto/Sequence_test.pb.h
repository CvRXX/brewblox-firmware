// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Sequence_test.proto

#ifndef PROTOBUF_INCLUDED_Sequence_5ftest_2eproto
#define PROTOBUF_INCLUDED_Sequence_5ftest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "brewblox_test.pb.h"
#include "nanopb_test.pb.h"
#include "IoArray_test.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Sequence_5ftest_2eproto 

namespace protobuf_Sequence_5ftest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Sequence_5ftest_2eproto
namespace blox_test {
namespace Sequence {
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class EnableDisable;
class EnableDisableDefaultTypeInternal;
extern EnableDisableDefaultTypeInternal _EnableDisable_default_instance_;
class Instruction;
class InstructionDefaultTypeInternal;
extern InstructionDefaultTypeInternal _Instruction_default_instance_;
class InstructionReset;
class InstructionResetDefaultTypeInternal;
extern InstructionResetDefaultTypeInternal _InstructionReset_default_instance_;
class Restart;
class RestartDefaultTypeInternal;
extern RestartDefaultTypeInternal _Restart_default_instance_;
class SetDigital;
class SetDigitalDefaultTypeInternal;
extern SetDigitalDefaultTypeInternal _SetDigital_default_instance_;
class SetPwm;
class SetPwmDefaultTypeInternal;
extern SetPwmDefaultTypeInternal _SetPwm_default_instance_;
class SetSetpoint;
class SetSetpointDefaultTypeInternal;
extern SetSetpointDefaultTypeInternal _SetSetpoint_default_instance_;
class StartWaitProfile;
class StartWaitProfileDefaultTypeInternal;
extern StartWaitProfileDefaultTypeInternal _StartWaitProfile_default_instance_;
class StartWaitSequence;
class StartWaitSequenceDefaultTypeInternal;
extern StartWaitSequenceDefaultTypeInternal _StartWaitSequence_default_instance_;
class WaitDigital;
class WaitDigitalDefaultTypeInternal;
extern WaitDigitalDefaultTypeInternal _WaitDigital_default_instance_;
class WaitDuration;
class WaitDurationDefaultTypeInternal;
extern WaitDurationDefaultTypeInternal _WaitDuration_default_instance_;
class WaitPwm;
class WaitPwmDefaultTypeInternal;
extern WaitPwmDefaultTypeInternal _WaitPwm_default_instance_;
class WaitSetpoint;
class WaitSetpointDefaultTypeInternal;
extern WaitSetpointDefaultTypeInternal _WaitSetpoint_default_instance_;
class WaitTemperature;
class WaitTemperatureDefaultTypeInternal;
extern WaitTemperatureDefaultTypeInternal _WaitTemperature_default_instance_;
class WaitTemperatureBoundary;
class WaitTemperatureBoundaryDefaultTypeInternal;
extern WaitTemperatureBoundaryDefaultTypeInternal _WaitTemperatureBoundary_default_instance_;
class WaitUntil;
class WaitUntilDefaultTypeInternal;
extern WaitUntilDefaultTypeInternal _WaitUntil_default_instance_;
}  // namespace Sequence
}  // namespace blox_test
namespace google {
namespace protobuf {
template<> ::blox_test::Sequence::Block* Arena::CreateMaybeMessage<::blox_test::Sequence::Block>(Arena*);
template<> ::blox_test::Sequence::EnableDisable* Arena::CreateMaybeMessage<::blox_test::Sequence::EnableDisable>(Arena*);
template<> ::blox_test::Sequence::Instruction* Arena::CreateMaybeMessage<::blox_test::Sequence::Instruction>(Arena*);
template<> ::blox_test::Sequence::InstructionReset* Arena::CreateMaybeMessage<::blox_test::Sequence::InstructionReset>(Arena*);
template<> ::blox_test::Sequence::Restart* Arena::CreateMaybeMessage<::blox_test::Sequence::Restart>(Arena*);
template<> ::blox_test::Sequence::SetDigital* Arena::CreateMaybeMessage<::blox_test::Sequence::SetDigital>(Arena*);
template<> ::blox_test::Sequence::SetPwm* Arena::CreateMaybeMessage<::blox_test::Sequence::SetPwm>(Arena*);
template<> ::blox_test::Sequence::SetSetpoint* Arena::CreateMaybeMessage<::blox_test::Sequence::SetSetpoint>(Arena*);
template<> ::blox_test::Sequence::StartWaitProfile* Arena::CreateMaybeMessage<::blox_test::Sequence::StartWaitProfile>(Arena*);
template<> ::blox_test::Sequence::StartWaitSequence* Arena::CreateMaybeMessage<::blox_test::Sequence::StartWaitSequence>(Arena*);
template<> ::blox_test::Sequence::WaitDigital* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitDigital>(Arena*);
template<> ::blox_test::Sequence::WaitDuration* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitDuration>(Arena*);
template<> ::blox_test::Sequence::WaitPwm* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitPwm>(Arena*);
template<> ::blox_test::Sequence::WaitSetpoint* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitSetpoint>(Arena*);
template<> ::blox_test::Sequence::WaitTemperature* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitTemperature>(Arena*);
template<> ::blox_test::Sequence::WaitTemperatureBoundary* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitTemperatureBoundary>(Arena*);
template<> ::blox_test::Sequence::WaitUntil* Arena::CreateMaybeMessage<::blox_test::Sequence::WaitUntil>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace blox_test {
namespace Sequence {

enum SequenceStatus {
  UNKNOWN = 0,
  DISABLED = 1,
  PAUSED = 2,
  ACTIVE = 3,
  WAITING = 4,
  DONE = 5,
  RESTART = 6,
  ERROR = 7,
  SequenceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SequenceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SequenceStatus_IsValid(int value);
const SequenceStatus SequenceStatus_MIN = UNKNOWN;
const SequenceStatus SequenceStatus_MAX = ERROR;
const int SequenceStatus_ARRAYSIZE = SequenceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SequenceStatus_descriptor();
inline const ::std::string& SequenceStatus_Name(SequenceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SequenceStatus_descriptor(), value);
}
inline bool SequenceStatus_Parse(
    const ::std::string& name, SequenceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SequenceStatus>(
    SequenceStatus_descriptor(), name, value);
}
enum SequenceError {
  NONE = 0,
  INVALID_ARGUMENT = 1,
  INVALID_TARGET = 2,
  INVALID_TARGET_TYPE = 3,
  TARGET_DISABLED = 4,
  SYSTEM_TIME_NOT_AVAILABLE = 5,
  SequenceError_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SequenceError_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SequenceError_IsValid(int value);
const SequenceError SequenceError_MIN = NONE;
const SequenceError SequenceError_MAX = SYSTEM_TIME_NOT_AVAILABLE;
const int SequenceError_ARRAYSIZE = SequenceError_MAX + 1;

const ::google::protobuf::EnumDescriptor* SequenceError_descriptor();
inline const ::std::string& SequenceError_Name(SequenceError value) {
  return ::google::protobuf::internal::NameOfEnum(
    SequenceError_descriptor(), value);
}
inline bool SequenceError_Parse(
    const ::std::string& name, SequenceError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SequenceError>(
    SequenceError_descriptor(), name, value);
}
// ===================================================================

class Restart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.Restart) */ {
 public:
  Restart();
  virtual ~Restart();

  Restart(const Restart& from);

  inline Restart& operator=(const Restart& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Restart(Restart&& from) noexcept
    : Restart() {
    *this = ::std::move(from);
  }

  inline Restart& operator=(Restart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Restart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Restart* internal_default_instance() {
    return reinterpret_cast<const Restart*>(
               &_Restart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Restart* other);
  friend void swap(Restart& a, Restart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Restart* New() const final {
    return CreateMaybeMessage<Restart>(NULL);
  }

  Restart* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Restart>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Restart& from);
  void MergeFrom(const Restart& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Restart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.Restart)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnableDisable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.EnableDisable) */ {
 public:
  EnableDisable();
  virtual ~EnableDisable();

  EnableDisable(const EnableDisable& from);

  inline EnableDisable& operator=(const EnableDisable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnableDisable(EnableDisable&& from) noexcept
    : EnableDisable() {
    *this = ::std::move(from);
  }

  inline EnableDisable& operator=(EnableDisable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableDisable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnableDisable* internal_default_instance() {
    return reinterpret_cast<const EnableDisable*>(
               &_EnableDisable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EnableDisable* other);
  friend void swap(EnableDisable& a, EnableDisable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnableDisable* New() const final {
    return CreateMaybeMessage<EnableDisable>(NULL);
  }

  EnableDisable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnableDisable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnableDisable& from);
  void MergeFrom(const EnableDisable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableDisable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.EnableDisable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitDuration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitDuration) */ {
 public:
  WaitDuration();
  virtual ~WaitDuration();

  WaitDuration(const WaitDuration& from);

  inline WaitDuration& operator=(const WaitDuration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitDuration(WaitDuration&& from) noexcept
    : WaitDuration() {
    *this = ::std::move(from);
  }

  inline WaitDuration& operator=(WaitDuration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitDuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitDuration* internal_default_instance() {
    return reinterpret_cast<const WaitDuration*>(
               &_WaitDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WaitDuration* other);
  friend void swap(WaitDuration& a, WaitDuration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitDuration* New() const final {
    return CreateMaybeMessage<WaitDuration>(NULL);
  }

  WaitDuration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitDuration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitDuration& from);
  void MergeFrom(const WaitDuration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitDuration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 duration = 1 [(.nanopb) = {
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitDuration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitUntil : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitUntil) */ {
 public:
  WaitUntil();
  virtual ~WaitUntil();

  WaitUntil(const WaitUntil& from);

  inline WaitUntil& operator=(const WaitUntil& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitUntil(WaitUntil&& from) noexcept
    : WaitUntil() {
    *this = ::std::move(from);
  }

  inline WaitUntil& operator=(WaitUntil&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitUntil& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitUntil* internal_default_instance() {
    return reinterpret_cast<const WaitUntil*>(
               &_WaitUntil_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(WaitUntil* other);
  friend void swap(WaitUntil& a, WaitUntil& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitUntil* New() const final {
    return CreateMaybeMessage<WaitUntil>(NULL);
  }

  WaitUntil* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitUntil>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitUntil& from);
  void MergeFrom(const WaitUntil& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitUntil* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 time = 1 [(.nanopb) = {
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitUntil)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitTemperature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitTemperature) */ {
 public:
  WaitTemperature();
  virtual ~WaitTemperature();

  WaitTemperature(const WaitTemperature& from);

  inline WaitTemperature& operator=(const WaitTemperature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitTemperature(WaitTemperature&& from) noexcept
    : WaitTemperature() {
    *this = ::std::move(from);
  }

  inline WaitTemperature& operator=(WaitTemperature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitTemperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitTemperature* internal_default_instance() {
    return reinterpret_cast<const WaitTemperature*>(
               &_WaitTemperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WaitTemperature* other);
  friend void swap(WaitTemperature& a, WaitTemperature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitTemperature* New() const final {
    return CreateMaybeMessage<WaitTemperature>(NULL);
  }

  WaitTemperature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitTemperature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitTemperature& from);
  void MergeFrom(const WaitTemperature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitTemperature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 lower = 2 [(.nanopb) = {
  void clear_lower();
  static const int kLowerFieldNumber = 2;
  ::google::protobuf::int32 lower() const;
  void set_lower(::google::protobuf::int32 value);

  // sint32 upper = 3 [(.nanopb) = {
  void clear_upper();
  static const int kUpperFieldNumber = 3;
  ::google::protobuf::int32 upper() const;
  void set_upper(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitTemperature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 lower_;
  ::google::protobuf::int32 upper_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitTemperatureBoundary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitTemperatureBoundary) */ {
 public:
  WaitTemperatureBoundary();
  virtual ~WaitTemperatureBoundary();

  WaitTemperatureBoundary(const WaitTemperatureBoundary& from);

  inline WaitTemperatureBoundary& operator=(const WaitTemperatureBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitTemperatureBoundary(WaitTemperatureBoundary&& from) noexcept
    : WaitTemperatureBoundary() {
    *this = ::std::move(from);
  }

  inline WaitTemperatureBoundary& operator=(WaitTemperatureBoundary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitTemperatureBoundary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitTemperatureBoundary* internal_default_instance() {
    return reinterpret_cast<const WaitTemperatureBoundary*>(
               &_WaitTemperatureBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(WaitTemperatureBoundary* other);
  friend void swap(WaitTemperatureBoundary& a, WaitTemperatureBoundary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitTemperatureBoundary* New() const final {
    return CreateMaybeMessage<WaitTemperatureBoundary>(NULL);
  }

  WaitTemperatureBoundary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitTemperatureBoundary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitTemperatureBoundary& from);
  void MergeFrom(const WaitTemperatureBoundary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitTemperatureBoundary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 value = 2 [(.nanopb) = {
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitTemperatureBoundary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetSetpoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.SetSetpoint) */ {
 public:
  SetSetpoint();
  virtual ~SetSetpoint();

  SetSetpoint(const SetSetpoint& from);

  inline SetSetpoint& operator=(const SetSetpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetSetpoint(SetSetpoint&& from) noexcept
    : SetSetpoint() {
    *this = ::std::move(from);
  }

  inline SetSetpoint& operator=(SetSetpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetSetpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetSetpoint* internal_default_instance() {
    return reinterpret_cast<const SetSetpoint*>(
               &_SetSetpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SetSetpoint* other);
  friend void swap(SetSetpoint& a, SetSetpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetSetpoint* New() const final {
    return CreateMaybeMessage<SetSetpoint>(NULL);
  }

  SetSetpoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetSetpoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetSetpoint& from);
  void MergeFrom(const SetSetpoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSetpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 setting = 2 [(.nanopb) = {
  void clear_setting();
  static const int kSettingFieldNumber = 2;
  ::google::protobuf::int32 setting() const;
  void set_setting(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.SetSetpoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 setting_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitSetpoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitSetpoint) */ {
 public:
  WaitSetpoint();
  virtual ~WaitSetpoint();

  WaitSetpoint(const WaitSetpoint& from);

  inline WaitSetpoint& operator=(const WaitSetpoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitSetpoint(WaitSetpoint&& from) noexcept
    : WaitSetpoint() {
    *this = ::std::move(from);
  }

  inline WaitSetpoint& operator=(WaitSetpoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitSetpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitSetpoint* internal_default_instance() {
    return reinterpret_cast<const WaitSetpoint*>(
               &_WaitSetpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WaitSetpoint* other);
  friend void swap(WaitSetpoint& a, WaitSetpoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitSetpoint* New() const final {
    return CreateMaybeMessage<WaitSetpoint>(NULL);
  }

  WaitSetpoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitSetpoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitSetpoint& from);
  void MergeFrom(const WaitSetpoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitSetpoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 precision = 2 [(.nanopb) = {
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitSetpoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 precision_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetDigital : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.SetDigital) */ {
 public:
  SetDigital();
  virtual ~SetDigital();

  SetDigital(const SetDigital& from);

  inline SetDigital& operator=(const SetDigital& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetDigital(SetDigital&& from) noexcept
    : SetDigital() {
    *this = ::std::move(from);
  }

  inline SetDigital& operator=(SetDigital&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetDigital& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetDigital* internal_default_instance() {
    return reinterpret_cast<const SetDigital*>(
               &_SetDigital_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SetDigital* other);
  friend void swap(SetDigital& a, SetDigital& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetDigital* New() const final {
    return CreateMaybeMessage<SetDigital>(NULL);
  }

  SetDigital* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetDigital>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetDigital& from);
  void MergeFrom(const SetDigital& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDigital* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // .blox_test.IoArray.DigitalState setting = 2;
  void clear_setting();
  static const int kSettingFieldNumber = 2;
  ::blox_test::IoArray::DigitalState setting() const;
  void set_setting(::blox_test::IoArray::DigitalState value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.SetDigital)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  int setting_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitDigital : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitDigital) */ {
 public:
  WaitDigital();
  virtual ~WaitDigital();

  WaitDigital(const WaitDigital& from);

  inline WaitDigital& operator=(const WaitDigital& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitDigital(WaitDigital&& from) noexcept
    : WaitDigital() {
    *this = ::std::move(from);
  }

  inline WaitDigital& operator=(WaitDigital&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitDigital& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitDigital* internal_default_instance() {
    return reinterpret_cast<const WaitDigital*>(
               &_WaitDigital_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(WaitDigital* other);
  friend void swap(WaitDigital& a, WaitDigital& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitDigital* New() const final {
    return CreateMaybeMessage<WaitDigital>(NULL);
  }

  WaitDigital* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitDigital>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitDigital& from);
  void MergeFrom(const WaitDigital& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitDigital* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitDigital)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetPwm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.SetPwm) */ {
 public:
  SetPwm();
  virtual ~SetPwm();

  SetPwm(const SetPwm& from);

  inline SetPwm& operator=(const SetPwm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetPwm(SetPwm&& from) noexcept
    : SetPwm() {
    *this = ::std::move(from);
  }

  inline SetPwm& operator=(SetPwm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPwm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetPwm* internal_default_instance() {
    return reinterpret_cast<const SetPwm*>(
               &_SetPwm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SetPwm* other);
  friend void swap(SetPwm& a, SetPwm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetPwm* New() const final {
    return CreateMaybeMessage<SetPwm>(NULL);
  }

  SetPwm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetPwm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetPwm& from);
  void MergeFrom(const SetPwm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPwm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // sint32 setting = 2 [(.nanopb) = {
  void clear_setting();
  static const int kSettingFieldNumber = 2;
  ::google::protobuf::int32 setting() const;
  void set_setting(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.SetPwm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::int32 setting_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitPwm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.WaitPwm) */ {
 public:
  WaitPwm();
  virtual ~WaitPwm();

  WaitPwm(const WaitPwm& from);

  inline WaitPwm& operator=(const WaitPwm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitPwm(WaitPwm&& from) noexcept
    : WaitPwm() {
    *this = ::std::move(from);
  }

  inline WaitPwm& operator=(WaitPwm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitPwm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitPwm* internal_default_instance() {
    return reinterpret_cast<const WaitPwm*>(
               &_WaitPwm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(WaitPwm* other);
  friend void swap(WaitPwm& a, WaitPwm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitPwm* New() const final {
    return CreateMaybeMessage<WaitPwm>(NULL);
  }

  WaitPwm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitPwm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitPwm& from);
  void MergeFrom(const WaitPwm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitPwm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.WaitPwm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartWaitProfile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.StartWaitProfile) */ {
 public:
  StartWaitProfile();
  virtual ~StartWaitProfile();

  StartWaitProfile(const StartWaitProfile& from);

  inline StartWaitProfile& operator=(const StartWaitProfile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartWaitProfile(StartWaitProfile&& from) noexcept
    : StartWaitProfile() {
    *this = ::std::move(from);
  }

  inline StartWaitProfile& operator=(StartWaitProfile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartWaitProfile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartWaitProfile* internal_default_instance() {
    return reinterpret_cast<const StartWaitProfile*>(
               &_StartWaitProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(StartWaitProfile* other);
  friend void swap(StartWaitProfile& a, StartWaitProfile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartWaitProfile* New() const final {
    return CreateMaybeMessage<StartWaitProfile>(NULL);
  }

  StartWaitProfile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartWaitProfile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartWaitProfile& from);
  void MergeFrom(const StartWaitProfile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartWaitProfile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.StartWaitProfile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartWaitSequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.StartWaitSequence) */ {
 public:
  StartWaitSequence();
  virtual ~StartWaitSequence();

  StartWaitSequence(const StartWaitSequence& from);

  inline StartWaitSequence& operator=(const StartWaitSequence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartWaitSequence(StartWaitSequence&& from) noexcept
    : StartWaitSequence() {
    *this = ::std::move(from);
  }

  inline StartWaitSequence& operator=(StartWaitSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartWaitSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartWaitSequence* internal_default_instance() {
    return reinterpret_cast<const StartWaitSequence*>(
               &_StartWaitSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StartWaitSequence* other);
  friend void swap(StartWaitSequence& a, StartWaitSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartWaitSequence* New() const final {
    return CreateMaybeMessage<StartWaitSequence>(NULL);
  }

  StartWaitSequence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartWaitSequence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartWaitSequence& from);
  void MergeFrom(const StartWaitSequence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartWaitSequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 target = 1 [(.nanopb) = {
  void clear_target();
  static const int kTargetFieldNumber = 1;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.StartWaitSequence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Instruction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.Instruction) */ {
 public:
  Instruction();
  virtual ~Instruction();

  Instruction(const Instruction& from);

  inline Instruction& operator=(const Instruction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instruction(Instruction&& from) noexcept
    : Instruction() {
    *this = ::std::move(from);
  }

  inline Instruction& operator=(Instruction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instruction& default_instance();

  enum InstructionOneofCase {
    kRestart = 1,
    kEnable = 2,
    kDisable = 3,
    kWaitDuration = 4,
    kWaitUntil = 5,
    kWaitTemperature = 6,
    kWaitTemperatureAbove = 7,
    kWaitTemperatureBelow = 8,
    kSetSetpoint = 9,
    kWaitSetpoint = 10,
    kSetDigital = 11,
    kWaitDigital = 12,
    kSetPwm = 13,
    kWaitPwm = 14,
    kStartProfile = 15,
    kWaitProfile = 16,
    kStartSequence = 17,
    kWaitSequence = 18,
    INSTRUCTION_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instruction* internal_default_instance() {
    return reinterpret_cast<const Instruction*>(
               &_Instruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Instruction* other);
  friend void swap(Instruction& a, Instruction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instruction* New() const final {
    return CreateMaybeMessage<Instruction>(NULL);
  }

  Instruction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instruction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instruction& from);
  void MergeFrom(const Instruction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instruction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .blox_test.Sequence.Restart restart = 1;
  bool has_restart() const;
  void clear_restart();
  static const int kRestartFieldNumber = 1;
  private:
  const ::blox_test::Sequence::Restart& _internal_restart() const;
  public:
  const ::blox_test::Sequence::Restart& restart() const;
  ::blox_test::Sequence::Restart* release_restart();
  ::blox_test::Sequence::Restart* mutable_restart();
  void set_allocated_restart(::blox_test::Sequence::Restart* restart);

  // .blox_test.Sequence.EnableDisable enable = 2;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  private:
  const ::blox_test::Sequence::EnableDisable& _internal_enable() const;
  public:
  const ::blox_test::Sequence::EnableDisable& enable() const;
  ::blox_test::Sequence::EnableDisable* release_enable();
  ::blox_test::Sequence::EnableDisable* mutable_enable();
  void set_allocated_enable(::blox_test::Sequence::EnableDisable* enable);

  // .blox_test.Sequence.EnableDisable disable = 3;
  bool has_disable() const;
  void clear_disable();
  static const int kDisableFieldNumber = 3;
  private:
  const ::blox_test::Sequence::EnableDisable& _internal_disable() const;
  public:
  const ::blox_test::Sequence::EnableDisable& disable() const;
  ::blox_test::Sequence::EnableDisable* release_disable();
  ::blox_test::Sequence::EnableDisable* mutable_disable();
  void set_allocated_disable(::blox_test::Sequence::EnableDisable* disable);

  // .blox_test.Sequence.WaitDuration waitDuration = 4;
  bool has_waitduration() const;
  void clear_waitduration();
  static const int kWaitDurationFieldNumber = 4;
  private:
  const ::blox_test::Sequence::WaitDuration& _internal_waitduration() const;
  public:
  const ::blox_test::Sequence::WaitDuration& waitduration() const;
  ::blox_test::Sequence::WaitDuration* release_waitduration();
  ::blox_test::Sequence::WaitDuration* mutable_waitduration();
  void set_allocated_waitduration(::blox_test::Sequence::WaitDuration* waitduration);

  // .blox_test.Sequence.WaitUntil waitUntil = 5;
  bool has_waituntil() const;
  void clear_waituntil();
  static const int kWaitUntilFieldNumber = 5;
  private:
  const ::blox_test::Sequence::WaitUntil& _internal_waituntil() const;
  public:
  const ::blox_test::Sequence::WaitUntil& waituntil() const;
  ::blox_test::Sequence::WaitUntil* release_waituntil();
  ::blox_test::Sequence::WaitUntil* mutable_waituntil();
  void set_allocated_waituntil(::blox_test::Sequence::WaitUntil* waituntil);

  // .blox_test.Sequence.WaitTemperature waitTemperature = 6;
  bool has_waittemperature() const;
  void clear_waittemperature();
  static const int kWaitTemperatureFieldNumber = 6;
  private:
  const ::blox_test::Sequence::WaitTemperature& _internal_waittemperature() const;
  public:
  const ::blox_test::Sequence::WaitTemperature& waittemperature() const;
  ::blox_test::Sequence::WaitTemperature* release_waittemperature();
  ::blox_test::Sequence::WaitTemperature* mutable_waittemperature();
  void set_allocated_waittemperature(::blox_test::Sequence::WaitTemperature* waittemperature);

  // .blox_test.Sequence.WaitTemperatureBoundary waitTemperatureAbove = 7;
  bool has_waittemperatureabove() const;
  void clear_waittemperatureabove();
  static const int kWaitTemperatureAboveFieldNumber = 7;
  private:
  const ::blox_test::Sequence::WaitTemperatureBoundary& _internal_waittemperatureabove() const;
  public:
  const ::blox_test::Sequence::WaitTemperatureBoundary& waittemperatureabove() const;
  ::blox_test::Sequence::WaitTemperatureBoundary* release_waittemperatureabove();
  ::blox_test::Sequence::WaitTemperatureBoundary* mutable_waittemperatureabove();
  void set_allocated_waittemperatureabove(::blox_test::Sequence::WaitTemperatureBoundary* waittemperatureabove);

  // .blox_test.Sequence.WaitTemperatureBoundary waitTemperatureBelow = 8;
  bool has_waittemperaturebelow() const;
  void clear_waittemperaturebelow();
  static const int kWaitTemperatureBelowFieldNumber = 8;
  private:
  const ::blox_test::Sequence::WaitTemperatureBoundary& _internal_waittemperaturebelow() const;
  public:
  const ::blox_test::Sequence::WaitTemperatureBoundary& waittemperaturebelow() const;
  ::blox_test::Sequence::WaitTemperatureBoundary* release_waittemperaturebelow();
  ::blox_test::Sequence::WaitTemperatureBoundary* mutable_waittemperaturebelow();
  void set_allocated_waittemperaturebelow(::blox_test::Sequence::WaitTemperatureBoundary* waittemperaturebelow);

  // .blox_test.Sequence.SetSetpoint setSetpoint = 9;
  bool has_setsetpoint() const;
  void clear_setsetpoint();
  static const int kSetSetpointFieldNumber = 9;
  private:
  const ::blox_test::Sequence::SetSetpoint& _internal_setsetpoint() const;
  public:
  const ::blox_test::Sequence::SetSetpoint& setsetpoint() const;
  ::blox_test::Sequence::SetSetpoint* release_setsetpoint();
  ::blox_test::Sequence::SetSetpoint* mutable_setsetpoint();
  void set_allocated_setsetpoint(::blox_test::Sequence::SetSetpoint* setsetpoint);

  // .blox_test.Sequence.WaitSetpoint waitSetpoint = 10;
  bool has_waitsetpoint() const;
  void clear_waitsetpoint();
  static const int kWaitSetpointFieldNumber = 10;
  private:
  const ::blox_test::Sequence::WaitSetpoint& _internal_waitsetpoint() const;
  public:
  const ::blox_test::Sequence::WaitSetpoint& waitsetpoint() const;
  ::blox_test::Sequence::WaitSetpoint* release_waitsetpoint();
  ::blox_test::Sequence::WaitSetpoint* mutable_waitsetpoint();
  void set_allocated_waitsetpoint(::blox_test::Sequence::WaitSetpoint* waitsetpoint);

  // .blox_test.Sequence.SetDigital setDigital = 11;
  bool has_setdigital() const;
  void clear_setdigital();
  static const int kSetDigitalFieldNumber = 11;
  private:
  const ::blox_test::Sequence::SetDigital& _internal_setdigital() const;
  public:
  const ::blox_test::Sequence::SetDigital& setdigital() const;
  ::blox_test::Sequence::SetDigital* release_setdigital();
  ::blox_test::Sequence::SetDigital* mutable_setdigital();
  void set_allocated_setdigital(::blox_test::Sequence::SetDigital* setdigital);

  // .blox_test.Sequence.WaitDigital waitDigital = 12;
  bool has_waitdigital() const;
  void clear_waitdigital();
  static const int kWaitDigitalFieldNumber = 12;
  private:
  const ::blox_test::Sequence::WaitDigital& _internal_waitdigital() const;
  public:
  const ::blox_test::Sequence::WaitDigital& waitdigital() const;
  ::blox_test::Sequence::WaitDigital* release_waitdigital();
  ::blox_test::Sequence::WaitDigital* mutable_waitdigital();
  void set_allocated_waitdigital(::blox_test::Sequence::WaitDigital* waitdigital);

  // .blox_test.Sequence.SetPwm setPwm = 13;
  bool has_setpwm() const;
  void clear_setpwm();
  static const int kSetPwmFieldNumber = 13;
  private:
  const ::blox_test::Sequence::SetPwm& _internal_setpwm() const;
  public:
  const ::blox_test::Sequence::SetPwm& setpwm() const;
  ::blox_test::Sequence::SetPwm* release_setpwm();
  ::blox_test::Sequence::SetPwm* mutable_setpwm();
  void set_allocated_setpwm(::blox_test::Sequence::SetPwm* setpwm);

  // .blox_test.Sequence.WaitPwm waitPwm = 14;
  bool has_waitpwm() const;
  void clear_waitpwm();
  static const int kWaitPwmFieldNumber = 14;
  private:
  const ::blox_test::Sequence::WaitPwm& _internal_waitpwm() const;
  public:
  const ::blox_test::Sequence::WaitPwm& waitpwm() const;
  ::blox_test::Sequence::WaitPwm* release_waitpwm();
  ::blox_test::Sequence::WaitPwm* mutable_waitpwm();
  void set_allocated_waitpwm(::blox_test::Sequence::WaitPwm* waitpwm);

  // .blox_test.Sequence.StartWaitProfile startProfile = 15;
  bool has_startprofile() const;
  void clear_startprofile();
  static const int kStartProfileFieldNumber = 15;
  private:
  const ::blox_test::Sequence::StartWaitProfile& _internal_startprofile() const;
  public:
  const ::blox_test::Sequence::StartWaitProfile& startprofile() const;
  ::blox_test::Sequence::StartWaitProfile* release_startprofile();
  ::blox_test::Sequence::StartWaitProfile* mutable_startprofile();
  void set_allocated_startprofile(::blox_test::Sequence::StartWaitProfile* startprofile);

  // .blox_test.Sequence.StartWaitProfile waitProfile = 16;
  bool has_waitprofile() const;
  void clear_waitprofile();
  static const int kWaitProfileFieldNumber = 16;
  private:
  const ::blox_test::Sequence::StartWaitProfile& _internal_waitprofile() const;
  public:
  const ::blox_test::Sequence::StartWaitProfile& waitprofile() const;
  ::blox_test::Sequence::StartWaitProfile* release_waitprofile();
  ::blox_test::Sequence::StartWaitProfile* mutable_waitprofile();
  void set_allocated_waitprofile(::blox_test::Sequence::StartWaitProfile* waitprofile);

  // .blox_test.Sequence.StartWaitSequence startSequence = 17;
  bool has_startsequence() const;
  void clear_startsequence();
  static const int kStartSequenceFieldNumber = 17;
  private:
  const ::blox_test::Sequence::StartWaitSequence& _internal_startsequence() const;
  public:
  const ::blox_test::Sequence::StartWaitSequence& startsequence() const;
  ::blox_test::Sequence::StartWaitSequence* release_startsequence();
  ::blox_test::Sequence::StartWaitSequence* mutable_startsequence();
  void set_allocated_startsequence(::blox_test::Sequence::StartWaitSequence* startsequence);

  // .blox_test.Sequence.StartWaitSequence waitSequence = 18;
  bool has_waitsequence() const;
  void clear_waitsequence();
  static const int kWaitSequenceFieldNumber = 18;
  private:
  const ::blox_test::Sequence::StartWaitSequence& _internal_waitsequence() const;
  public:
  const ::blox_test::Sequence::StartWaitSequence& waitsequence() const;
  ::blox_test::Sequence::StartWaitSequence* release_waitsequence();
  ::blox_test::Sequence::StartWaitSequence* mutable_waitsequence();
  void set_allocated_waitsequence(::blox_test::Sequence::StartWaitSequence* waitsequence);

  void clear_instruction_oneof();
  InstructionOneofCase instruction_oneof_case() const;
  // @@protoc_insertion_point(class_scope:blox_test.Sequence.Instruction)
 private:
  void set_has_restart();
  void set_has_enable();
  void set_has_disable();
  void set_has_waitduration();
  void set_has_waituntil();
  void set_has_waittemperature();
  void set_has_waittemperatureabove();
  void set_has_waittemperaturebelow();
  void set_has_setsetpoint();
  void set_has_waitsetpoint();
  void set_has_setdigital();
  void set_has_waitdigital();
  void set_has_setpwm();
  void set_has_waitpwm();
  void set_has_startprofile();
  void set_has_waitprofile();
  void set_has_startsequence();
  void set_has_waitsequence();

  inline bool has_instruction_oneof() const;
  inline void clear_has_instruction_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InstructionOneofUnion {
    InstructionOneofUnion() {}
    ::blox_test::Sequence::Restart* restart_;
    ::blox_test::Sequence::EnableDisable* enable_;
    ::blox_test::Sequence::EnableDisable* disable_;
    ::blox_test::Sequence::WaitDuration* waitduration_;
    ::blox_test::Sequence::WaitUntil* waituntil_;
    ::blox_test::Sequence::WaitTemperature* waittemperature_;
    ::blox_test::Sequence::WaitTemperatureBoundary* waittemperatureabove_;
    ::blox_test::Sequence::WaitTemperatureBoundary* waittemperaturebelow_;
    ::blox_test::Sequence::SetSetpoint* setsetpoint_;
    ::blox_test::Sequence::WaitSetpoint* waitsetpoint_;
    ::blox_test::Sequence::SetDigital* setdigital_;
    ::blox_test::Sequence::WaitDigital* waitdigital_;
    ::blox_test::Sequence::SetPwm* setpwm_;
    ::blox_test::Sequence::WaitPwm* waitpwm_;
    ::blox_test::Sequence::StartWaitProfile* startprofile_;
    ::blox_test::Sequence::StartWaitProfile* waitprofile_;
    ::blox_test::Sequence::StartWaitSequence* startsequence_;
    ::blox_test::Sequence::StartWaitSequence* waitsequence_;
  } instruction_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstructionReset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.InstructionReset) */ {
 public:
  InstructionReset();
  virtual ~InstructionReset();

  InstructionReset(const InstructionReset& from);

  inline InstructionReset& operator=(const InstructionReset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstructionReset(InstructionReset&& from) noexcept
    : InstructionReset() {
    *this = ::std::move(from);
  }

  inline InstructionReset& operator=(InstructionReset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstructionReset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstructionReset* internal_default_instance() {
    return reinterpret_cast<const InstructionReset*>(
               &_InstructionReset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(InstructionReset* other);
  friend void swap(InstructionReset& a, InstructionReset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstructionReset* New() const final {
    return CreateMaybeMessage<InstructionReset>(NULL);
  }

  InstructionReset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstructionReset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InstructionReset& from);
  void MergeFrom(const InstructionReset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstructionReset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 activeInstruction = 1 [(.nanopb) = {
  void clear_activeinstruction();
  static const int kActiveInstructionFieldNumber = 1;
  ::google::protobuf::uint32 activeinstruction() const;
  void set_activeinstruction(::google::protobuf::uint32 value);

  // uint32 activeInstructionStartedAt = 2 [(.nanopb) = {
  void clear_activeinstructionstartedat();
  static const int kActiveInstructionStartedAtFieldNumber = 2;
  ::google::protobuf::uint32 activeinstructionstartedat() const;
  void set_activeinstructionstartedat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox_test.Sequence.InstructionReset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 activeinstruction_;
  ::google::protobuf::uint32 activeinstructionstartedat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:blox_test.Sequence.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  enum ResetOneofCase {
    kReset = 3,
    RESET_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox_test.Sequence.Instruction instructions = 2;
  int instructions_size() const;
  void clear_instructions();
  static const int kInstructionsFieldNumber = 2;
  ::blox_test::Sequence::Instruction* mutable_instructions(int index);
  ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >*
      mutable_instructions();
  const ::blox_test::Sequence::Instruction& instructions(int index) const;
  ::blox_test::Sequence::Instruction* add_instructions();
  const ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >&
      instructions() const;

  // bool enabled = 1 [(.brewblox.field) = {
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // uint32 activeInstruction = 4 [(.nanopb) = {
  void clear_activeinstruction();
  static const int kActiveInstructionFieldNumber = 4;
  ::google::protobuf::uint32 activeinstruction() const;
  void set_activeinstruction(::google::protobuf::uint32 value);

  // uint32 activeInstructionStartedAt = 5 [(.nanopb) = {
  void clear_activeinstructionstartedat();
  static const int kActiveInstructionStartedAtFieldNumber = 5;
  ::google::protobuf::uint32 activeinstructionstartedat() const;
  void set_activeinstructionstartedat(::google::protobuf::uint32 value);

  // uint32 disabledAt = 6 [(.nanopb) = {
  void clear_disabledat();
  static const int kDisabledAtFieldNumber = 6;
  ::google::protobuf::uint32 disabledat() const;
  void set_disabledat(::google::protobuf::uint32 value);

  // uint32 disabledDuration = 7 [(.nanopb) = {
  void clear_disabledduration();
  static const int kDisabledDurationFieldNumber = 7;
  ::google::protobuf::uint32 disabledduration() const;
  void set_disabledduration(::google::protobuf::uint32 value);

  // .blox_test.Sequence.SequenceStatus status = 8 [(.brewblox.field) = {
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::blox_test::Sequence::SequenceStatus status() const;
  void set_status(::blox_test::Sequence::SequenceStatus value);

  // .blox_test.Sequence.SequenceError error = 9 [(.brewblox.field) = {
  void clear_error();
  static const int kErrorFieldNumber = 9;
  ::blox_test::Sequence::SequenceError error() const;
  void set_error(::blox_test::Sequence::SequenceError value);

  // .blox_test.Sequence.InstructionReset reset = 3;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 3;
  private:
  const ::blox_test::Sequence::InstructionReset& _internal_reset() const;
  public:
  const ::blox_test::Sequence::InstructionReset& reset() const;
  ::blox_test::Sequence::InstructionReset* release_reset();
  ::blox_test::Sequence::InstructionReset* mutable_reset();
  void set_allocated_reset(::blox_test::Sequence::InstructionReset* reset);

  void clear_reset_oneof();
  ResetOneofCase reset_oneof_case() const;
  // @@protoc_insertion_point(class_scope:blox_test.Sequence.Block)
 private:
  void set_has_reset();

  inline bool has_reset_oneof() const;
  inline void clear_has_reset_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction > instructions_;
  bool enabled_;
  ::google::protobuf::uint32 activeinstruction_;
  ::google::protobuf::uint32 activeinstructionstartedat_;
  ::google::protobuf::uint32 disabledat_;
  ::google::protobuf::uint32 disabledduration_;
  int status_;
  int error_;
  union ResetOneofUnion {
    ResetOneofUnion() {}
    ::blox_test::Sequence::InstructionReset* reset_;
  } reset_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Sequence_5ftest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Restart

// -------------------------------------------------------------------

// EnableDisable

// uint32 target = 1 [(.nanopb) = {
inline void EnableDisable::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 EnableDisable::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.EnableDisable.target)
  return target_;
}
inline void EnableDisable::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.EnableDisable.target)
}

// -------------------------------------------------------------------

// WaitDuration

// uint32 duration = 1 [(.nanopb) = {
inline void WaitDuration::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 WaitDuration::duration() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitDuration.duration)
  return duration_;
}
inline void WaitDuration::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitDuration.duration)
}

// -------------------------------------------------------------------

// WaitUntil

// uint32 time = 1 [(.nanopb) = {
inline void WaitUntil::clear_time() {
  time_ = 0u;
}
inline ::google::protobuf::uint32 WaitUntil::time() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitUntil.time)
  return time_;
}
inline void WaitUntil::set_time(::google::protobuf::uint32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitUntil.time)
}

// -------------------------------------------------------------------

// WaitTemperature

// uint32 target = 1 [(.nanopb) = {
inline void WaitTemperature::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitTemperature::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperature.target)
  return target_;
}
inline void WaitTemperature::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperature.target)
}

// sint32 lower = 2 [(.nanopb) = {
inline void WaitTemperature::clear_lower() {
  lower_ = 0;
}
inline ::google::protobuf::int32 WaitTemperature::lower() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperature.lower)
  return lower_;
}
inline void WaitTemperature::set_lower(::google::protobuf::int32 value) {
  
  lower_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperature.lower)
}

// sint32 upper = 3 [(.nanopb) = {
inline void WaitTemperature::clear_upper() {
  upper_ = 0;
}
inline ::google::protobuf::int32 WaitTemperature::upper() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperature.upper)
  return upper_;
}
inline void WaitTemperature::set_upper(::google::protobuf::int32 value) {
  
  upper_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperature.upper)
}

// -------------------------------------------------------------------

// WaitTemperatureBoundary

// uint32 target = 1 [(.nanopb) = {
inline void WaitTemperatureBoundary::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitTemperatureBoundary::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperatureBoundary.target)
  return target_;
}
inline void WaitTemperatureBoundary::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperatureBoundary.target)
}

// sint32 value = 2 [(.nanopb) = {
inline void WaitTemperatureBoundary::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 WaitTemperatureBoundary::value() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitTemperatureBoundary.value)
  return value_;
}
inline void WaitTemperatureBoundary::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitTemperatureBoundary.value)
}

// -------------------------------------------------------------------

// SetSetpoint

// uint32 target = 1 [(.nanopb) = {
inline void SetSetpoint::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 SetSetpoint::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetSetpoint.target)
  return target_;
}
inline void SetSetpoint::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetSetpoint.target)
}

// sint32 setting = 2 [(.nanopb) = {
inline void SetSetpoint::clear_setting() {
  setting_ = 0;
}
inline ::google::protobuf::int32 SetSetpoint::setting() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetSetpoint.setting)
  return setting_;
}
inline void SetSetpoint::set_setting(::google::protobuf::int32 value) {
  
  setting_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetSetpoint.setting)
}

// -------------------------------------------------------------------

// WaitSetpoint

// uint32 target = 1 [(.nanopb) = {
inline void WaitSetpoint::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitSetpoint::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitSetpoint.target)
  return target_;
}
inline void WaitSetpoint::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitSetpoint.target)
}

// sint32 precision = 2 [(.nanopb) = {
inline void WaitSetpoint::clear_precision() {
  precision_ = 0;
}
inline ::google::protobuf::int32 WaitSetpoint::precision() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitSetpoint.precision)
  return precision_;
}
inline void WaitSetpoint::set_precision(::google::protobuf::int32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitSetpoint.precision)
}

// -------------------------------------------------------------------

// SetDigital

// uint32 target = 1 [(.nanopb) = {
inline void SetDigital::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 SetDigital::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetDigital.target)
  return target_;
}
inline void SetDigital::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetDigital.target)
}

// .blox_test.IoArray.DigitalState setting = 2;
inline void SetDigital::clear_setting() {
  setting_ = 0;
}
inline ::blox_test::IoArray::DigitalState SetDigital::setting() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetDigital.setting)
  return static_cast< ::blox_test::IoArray::DigitalState >(setting_);
}
inline void SetDigital::set_setting(::blox_test::IoArray::DigitalState value) {
  
  setting_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetDigital.setting)
}

// -------------------------------------------------------------------

// WaitDigital

// uint32 target = 1 [(.nanopb) = {
inline void WaitDigital::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitDigital::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitDigital.target)
  return target_;
}
inline void WaitDigital::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitDigital.target)
}

// -------------------------------------------------------------------

// SetPwm

// uint32 target = 1 [(.nanopb) = {
inline void SetPwm::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 SetPwm::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetPwm.target)
  return target_;
}
inline void SetPwm::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetPwm.target)
}

// sint32 setting = 2 [(.nanopb) = {
inline void SetPwm::clear_setting() {
  setting_ = 0;
}
inline ::google::protobuf::int32 SetPwm::setting() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.SetPwm.setting)
  return setting_;
}
inline void SetPwm::set_setting(::google::protobuf::int32 value) {
  
  setting_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.SetPwm.setting)
}

// -------------------------------------------------------------------

// WaitPwm

// uint32 target = 1 [(.nanopb) = {
inline void WaitPwm::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 WaitPwm::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.WaitPwm.target)
  return target_;
}
inline void WaitPwm::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.WaitPwm.target)
}

// -------------------------------------------------------------------

// StartWaitProfile

// uint32 target = 1 [(.nanopb) = {
inline void StartWaitProfile::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 StartWaitProfile::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.StartWaitProfile.target)
  return target_;
}
inline void StartWaitProfile::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.StartWaitProfile.target)
}

// -------------------------------------------------------------------

// StartWaitSequence

// uint32 target = 1 [(.nanopb) = {
inline void StartWaitSequence::clear_target() {
  target_ = 0u;
}
inline ::google::protobuf::uint32 StartWaitSequence::target() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.StartWaitSequence.target)
  return target_;
}
inline void StartWaitSequence::set_target(::google::protobuf::uint32 value) {
  
  target_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.StartWaitSequence.target)
}

// -------------------------------------------------------------------

// Instruction

// .blox_test.Sequence.Restart restart = 1;
inline bool Instruction::has_restart() const {
  return instruction_oneof_case() == kRestart;
}
inline void Instruction::set_has_restart() {
  _oneof_case_[0] = kRestart;
}
inline void Instruction::clear_restart() {
  if (has_restart()) {
    delete instruction_oneof_.restart_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::Restart& Instruction::_internal_restart() const {
  return *instruction_oneof_.restart_;
}
inline ::blox_test::Sequence::Restart* Instruction::release_restart() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.restart)
  if (has_restart()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::Restart* temp = instruction_oneof_.restart_;
    instruction_oneof_.restart_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::Restart& Instruction::restart() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.restart)
  return has_restart()
      ? *instruction_oneof_.restart_
      : *reinterpret_cast< ::blox_test::Sequence::Restart*>(&::blox_test::Sequence::_Restart_default_instance_);
}
inline ::blox_test::Sequence::Restart* Instruction::mutable_restart() {
  if (!has_restart()) {
    clear_instruction_oneof();
    set_has_restart();
    instruction_oneof_.restart_ = CreateMaybeMessage< ::blox_test::Sequence::Restart >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.restart)
  return instruction_oneof_.restart_;
}

// .blox_test.Sequence.EnableDisable enable = 2;
inline bool Instruction::has_enable() const {
  return instruction_oneof_case() == kEnable;
}
inline void Instruction::set_has_enable() {
  _oneof_case_[0] = kEnable;
}
inline void Instruction::clear_enable() {
  if (has_enable()) {
    delete instruction_oneof_.enable_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::_internal_enable() const {
  return *instruction_oneof_.enable_;
}
inline ::blox_test::Sequence::EnableDisable* Instruction::release_enable() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.enable)
  if (has_enable()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::EnableDisable* temp = instruction_oneof_.enable_;
    instruction_oneof_.enable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::enable() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.enable)
  return has_enable()
      ? *instruction_oneof_.enable_
      : *reinterpret_cast< ::blox_test::Sequence::EnableDisable*>(&::blox_test::Sequence::_EnableDisable_default_instance_);
}
inline ::blox_test::Sequence::EnableDisable* Instruction::mutable_enable() {
  if (!has_enable()) {
    clear_instruction_oneof();
    set_has_enable();
    instruction_oneof_.enable_ = CreateMaybeMessage< ::blox_test::Sequence::EnableDisable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.enable)
  return instruction_oneof_.enable_;
}

// .blox_test.Sequence.EnableDisable disable = 3;
inline bool Instruction::has_disable() const {
  return instruction_oneof_case() == kDisable;
}
inline void Instruction::set_has_disable() {
  _oneof_case_[0] = kDisable;
}
inline void Instruction::clear_disable() {
  if (has_disable()) {
    delete instruction_oneof_.disable_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::_internal_disable() const {
  return *instruction_oneof_.disable_;
}
inline ::blox_test::Sequence::EnableDisable* Instruction::release_disable() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.disable)
  if (has_disable()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::EnableDisable* temp = instruction_oneof_.disable_;
    instruction_oneof_.disable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::EnableDisable& Instruction::disable() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.disable)
  return has_disable()
      ? *instruction_oneof_.disable_
      : *reinterpret_cast< ::blox_test::Sequence::EnableDisable*>(&::blox_test::Sequence::_EnableDisable_default_instance_);
}
inline ::blox_test::Sequence::EnableDisable* Instruction::mutable_disable() {
  if (!has_disable()) {
    clear_instruction_oneof();
    set_has_disable();
    instruction_oneof_.disable_ = CreateMaybeMessage< ::blox_test::Sequence::EnableDisable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.disable)
  return instruction_oneof_.disable_;
}

// .blox_test.Sequence.WaitDuration waitDuration = 4;
inline bool Instruction::has_waitduration() const {
  return instruction_oneof_case() == kWaitDuration;
}
inline void Instruction::set_has_waitduration() {
  _oneof_case_[0] = kWaitDuration;
}
inline void Instruction::clear_waitduration() {
  if (has_waitduration()) {
    delete instruction_oneof_.waitduration_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitDuration& Instruction::_internal_waitduration() const {
  return *instruction_oneof_.waitduration_;
}
inline ::blox_test::Sequence::WaitDuration* Instruction::release_waitduration() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitDuration)
  if (has_waitduration()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitDuration* temp = instruction_oneof_.waitduration_;
    instruction_oneof_.waitduration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitDuration& Instruction::waitduration() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitDuration)
  return has_waitduration()
      ? *instruction_oneof_.waitduration_
      : *reinterpret_cast< ::blox_test::Sequence::WaitDuration*>(&::blox_test::Sequence::_WaitDuration_default_instance_);
}
inline ::blox_test::Sequence::WaitDuration* Instruction::mutable_waitduration() {
  if (!has_waitduration()) {
    clear_instruction_oneof();
    set_has_waitduration();
    instruction_oneof_.waitduration_ = CreateMaybeMessage< ::blox_test::Sequence::WaitDuration >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitDuration)
  return instruction_oneof_.waitduration_;
}

// .blox_test.Sequence.WaitUntil waitUntil = 5;
inline bool Instruction::has_waituntil() const {
  return instruction_oneof_case() == kWaitUntil;
}
inline void Instruction::set_has_waituntil() {
  _oneof_case_[0] = kWaitUntil;
}
inline void Instruction::clear_waituntil() {
  if (has_waituntil()) {
    delete instruction_oneof_.waituntil_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitUntil& Instruction::_internal_waituntil() const {
  return *instruction_oneof_.waituntil_;
}
inline ::blox_test::Sequence::WaitUntil* Instruction::release_waituntil() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitUntil)
  if (has_waituntil()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitUntil* temp = instruction_oneof_.waituntil_;
    instruction_oneof_.waituntil_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitUntil& Instruction::waituntil() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitUntil)
  return has_waituntil()
      ? *instruction_oneof_.waituntil_
      : *reinterpret_cast< ::blox_test::Sequence::WaitUntil*>(&::blox_test::Sequence::_WaitUntil_default_instance_);
}
inline ::blox_test::Sequence::WaitUntil* Instruction::mutable_waituntil() {
  if (!has_waituntil()) {
    clear_instruction_oneof();
    set_has_waituntil();
    instruction_oneof_.waituntil_ = CreateMaybeMessage< ::blox_test::Sequence::WaitUntil >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitUntil)
  return instruction_oneof_.waituntil_;
}

// .blox_test.Sequence.WaitTemperature waitTemperature = 6;
inline bool Instruction::has_waittemperature() const {
  return instruction_oneof_case() == kWaitTemperature;
}
inline void Instruction::set_has_waittemperature() {
  _oneof_case_[0] = kWaitTemperature;
}
inline void Instruction::clear_waittemperature() {
  if (has_waittemperature()) {
    delete instruction_oneof_.waittemperature_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitTemperature& Instruction::_internal_waittemperature() const {
  return *instruction_oneof_.waittemperature_;
}
inline ::blox_test::Sequence::WaitTemperature* Instruction::release_waittemperature() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitTemperature)
  if (has_waittemperature()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitTemperature* temp = instruction_oneof_.waittemperature_;
    instruction_oneof_.waittemperature_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitTemperature& Instruction::waittemperature() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitTemperature)
  return has_waittemperature()
      ? *instruction_oneof_.waittemperature_
      : *reinterpret_cast< ::blox_test::Sequence::WaitTemperature*>(&::blox_test::Sequence::_WaitTemperature_default_instance_);
}
inline ::blox_test::Sequence::WaitTemperature* Instruction::mutable_waittemperature() {
  if (!has_waittemperature()) {
    clear_instruction_oneof();
    set_has_waittemperature();
    instruction_oneof_.waittemperature_ = CreateMaybeMessage< ::blox_test::Sequence::WaitTemperature >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitTemperature)
  return instruction_oneof_.waittemperature_;
}

// .blox_test.Sequence.WaitTemperatureBoundary waitTemperatureAbove = 7;
inline bool Instruction::has_waittemperatureabove() const {
  return instruction_oneof_case() == kWaitTemperatureAbove;
}
inline void Instruction::set_has_waittemperatureabove() {
  _oneof_case_[0] = kWaitTemperatureAbove;
}
inline void Instruction::clear_waittemperatureabove() {
  if (has_waittemperatureabove()) {
    delete instruction_oneof_.waittemperatureabove_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::_internal_waittemperatureabove() const {
  return *instruction_oneof_.waittemperatureabove_;
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::release_waittemperatureabove() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitTemperatureAbove)
  if (has_waittemperatureabove()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitTemperatureBoundary* temp = instruction_oneof_.waittemperatureabove_;
    instruction_oneof_.waittemperatureabove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::waittemperatureabove() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitTemperatureAbove)
  return has_waittemperatureabove()
      ? *instruction_oneof_.waittemperatureabove_
      : *reinterpret_cast< ::blox_test::Sequence::WaitTemperatureBoundary*>(&::blox_test::Sequence::_WaitTemperatureBoundary_default_instance_);
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::mutable_waittemperatureabove() {
  if (!has_waittemperatureabove()) {
    clear_instruction_oneof();
    set_has_waittemperatureabove();
    instruction_oneof_.waittemperatureabove_ = CreateMaybeMessage< ::blox_test::Sequence::WaitTemperatureBoundary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitTemperatureAbove)
  return instruction_oneof_.waittemperatureabove_;
}

// .blox_test.Sequence.WaitTemperatureBoundary waitTemperatureBelow = 8;
inline bool Instruction::has_waittemperaturebelow() const {
  return instruction_oneof_case() == kWaitTemperatureBelow;
}
inline void Instruction::set_has_waittemperaturebelow() {
  _oneof_case_[0] = kWaitTemperatureBelow;
}
inline void Instruction::clear_waittemperaturebelow() {
  if (has_waittemperaturebelow()) {
    delete instruction_oneof_.waittemperaturebelow_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::_internal_waittemperaturebelow() const {
  return *instruction_oneof_.waittemperaturebelow_;
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::release_waittemperaturebelow() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitTemperatureBelow)
  if (has_waittemperaturebelow()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitTemperatureBoundary* temp = instruction_oneof_.waittemperaturebelow_;
    instruction_oneof_.waittemperaturebelow_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitTemperatureBoundary& Instruction::waittemperaturebelow() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitTemperatureBelow)
  return has_waittemperaturebelow()
      ? *instruction_oneof_.waittemperaturebelow_
      : *reinterpret_cast< ::blox_test::Sequence::WaitTemperatureBoundary*>(&::blox_test::Sequence::_WaitTemperatureBoundary_default_instance_);
}
inline ::blox_test::Sequence::WaitTemperatureBoundary* Instruction::mutable_waittemperaturebelow() {
  if (!has_waittemperaturebelow()) {
    clear_instruction_oneof();
    set_has_waittemperaturebelow();
    instruction_oneof_.waittemperaturebelow_ = CreateMaybeMessage< ::blox_test::Sequence::WaitTemperatureBoundary >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitTemperatureBelow)
  return instruction_oneof_.waittemperaturebelow_;
}

// .blox_test.Sequence.SetSetpoint setSetpoint = 9;
inline bool Instruction::has_setsetpoint() const {
  return instruction_oneof_case() == kSetSetpoint;
}
inline void Instruction::set_has_setsetpoint() {
  _oneof_case_[0] = kSetSetpoint;
}
inline void Instruction::clear_setsetpoint() {
  if (has_setsetpoint()) {
    delete instruction_oneof_.setsetpoint_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::SetSetpoint& Instruction::_internal_setsetpoint() const {
  return *instruction_oneof_.setsetpoint_;
}
inline ::blox_test::Sequence::SetSetpoint* Instruction::release_setsetpoint() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.setSetpoint)
  if (has_setsetpoint()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::SetSetpoint* temp = instruction_oneof_.setsetpoint_;
    instruction_oneof_.setsetpoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::SetSetpoint& Instruction::setsetpoint() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.setSetpoint)
  return has_setsetpoint()
      ? *instruction_oneof_.setsetpoint_
      : *reinterpret_cast< ::blox_test::Sequence::SetSetpoint*>(&::blox_test::Sequence::_SetSetpoint_default_instance_);
}
inline ::blox_test::Sequence::SetSetpoint* Instruction::mutable_setsetpoint() {
  if (!has_setsetpoint()) {
    clear_instruction_oneof();
    set_has_setsetpoint();
    instruction_oneof_.setsetpoint_ = CreateMaybeMessage< ::blox_test::Sequence::SetSetpoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.setSetpoint)
  return instruction_oneof_.setsetpoint_;
}

// .blox_test.Sequence.WaitSetpoint waitSetpoint = 10;
inline bool Instruction::has_waitsetpoint() const {
  return instruction_oneof_case() == kWaitSetpoint;
}
inline void Instruction::set_has_waitsetpoint() {
  _oneof_case_[0] = kWaitSetpoint;
}
inline void Instruction::clear_waitsetpoint() {
  if (has_waitsetpoint()) {
    delete instruction_oneof_.waitsetpoint_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitSetpoint& Instruction::_internal_waitsetpoint() const {
  return *instruction_oneof_.waitsetpoint_;
}
inline ::blox_test::Sequence::WaitSetpoint* Instruction::release_waitsetpoint() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitSetpoint)
  if (has_waitsetpoint()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitSetpoint* temp = instruction_oneof_.waitsetpoint_;
    instruction_oneof_.waitsetpoint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitSetpoint& Instruction::waitsetpoint() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitSetpoint)
  return has_waitsetpoint()
      ? *instruction_oneof_.waitsetpoint_
      : *reinterpret_cast< ::blox_test::Sequence::WaitSetpoint*>(&::blox_test::Sequence::_WaitSetpoint_default_instance_);
}
inline ::blox_test::Sequence::WaitSetpoint* Instruction::mutable_waitsetpoint() {
  if (!has_waitsetpoint()) {
    clear_instruction_oneof();
    set_has_waitsetpoint();
    instruction_oneof_.waitsetpoint_ = CreateMaybeMessage< ::blox_test::Sequence::WaitSetpoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitSetpoint)
  return instruction_oneof_.waitsetpoint_;
}

// .blox_test.Sequence.SetDigital setDigital = 11;
inline bool Instruction::has_setdigital() const {
  return instruction_oneof_case() == kSetDigital;
}
inline void Instruction::set_has_setdigital() {
  _oneof_case_[0] = kSetDigital;
}
inline void Instruction::clear_setdigital() {
  if (has_setdigital()) {
    delete instruction_oneof_.setdigital_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::SetDigital& Instruction::_internal_setdigital() const {
  return *instruction_oneof_.setdigital_;
}
inline ::blox_test::Sequence::SetDigital* Instruction::release_setdigital() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.setDigital)
  if (has_setdigital()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::SetDigital* temp = instruction_oneof_.setdigital_;
    instruction_oneof_.setdigital_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::SetDigital& Instruction::setdigital() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.setDigital)
  return has_setdigital()
      ? *instruction_oneof_.setdigital_
      : *reinterpret_cast< ::blox_test::Sequence::SetDigital*>(&::blox_test::Sequence::_SetDigital_default_instance_);
}
inline ::blox_test::Sequence::SetDigital* Instruction::mutable_setdigital() {
  if (!has_setdigital()) {
    clear_instruction_oneof();
    set_has_setdigital();
    instruction_oneof_.setdigital_ = CreateMaybeMessage< ::blox_test::Sequence::SetDigital >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.setDigital)
  return instruction_oneof_.setdigital_;
}

// .blox_test.Sequence.WaitDigital waitDigital = 12;
inline bool Instruction::has_waitdigital() const {
  return instruction_oneof_case() == kWaitDigital;
}
inline void Instruction::set_has_waitdigital() {
  _oneof_case_[0] = kWaitDigital;
}
inline void Instruction::clear_waitdigital() {
  if (has_waitdigital()) {
    delete instruction_oneof_.waitdigital_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitDigital& Instruction::_internal_waitdigital() const {
  return *instruction_oneof_.waitdigital_;
}
inline ::blox_test::Sequence::WaitDigital* Instruction::release_waitdigital() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitDigital)
  if (has_waitdigital()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitDigital* temp = instruction_oneof_.waitdigital_;
    instruction_oneof_.waitdigital_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitDigital& Instruction::waitdigital() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitDigital)
  return has_waitdigital()
      ? *instruction_oneof_.waitdigital_
      : *reinterpret_cast< ::blox_test::Sequence::WaitDigital*>(&::blox_test::Sequence::_WaitDigital_default_instance_);
}
inline ::blox_test::Sequence::WaitDigital* Instruction::mutable_waitdigital() {
  if (!has_waitdigital()) {
    clear_instruction_oneof();
    set_has_waitdigital();
    instruction_oneof_.waitdigital_ = CreateMaybeMessage< ::blox_test::Sequence::WaitDigital >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitDigital)
  return instruction_oneof_.waitdigital_;
}

// .blox_test.Sequence.SetPwm setPwm = 13;
inline bool Instruction::has_setpwm() const {
  return instruction_oneof_case() == kSetPwm;
}
inline void Instruction::set_has_setpwm() {
  _oneof_case_[0] = kSetPwm;
}
inline void Instruction::clear_setpwm() {
  if (has_setpwm()) {
    delete instruction_oneof_.setpwm_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::SetPwm& Instruction::_internal_setpwm() const {
  return *instruction_oneof_.setpwm_;
}
inline ::blox_test::Sequence::SetPwm* Instruction::release_setpwm() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.setPwm)
  if (has_setpwm()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::SetPwm* temp = instruction_oneof_.setpwm_;
    instruction_oneof_.setpwm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::SetPwm& Instruction::setpwm() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.setPwm)
  return has_setpwm()
      ? *instruction_oneof_.setpwm_
      : *reinterpret_cast< ::blox_test::Sequence::SetPwm*>(&::blox_test::Sequence::_SetPwm_default_instance_);
}
inline ::blox_test::Sequence::SetPwm* Instruction::mutable_setpwm() {
  if (!has_setpwm()) {
    clear_instruction_oneof();
    set_has_setpwm();
    instruction_oneof_.setpwm_ = CreateMaybeMessage< ::blox_test::Sequence::SetPwm >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.setPwm)
  return instruction_oneof_.setpwm_;
}

// .blox_test.Sequence.WaitPwm waitPwm = 14;
inline bool Instruction::has_waitpwm() const {
  return instruction_oneof_case() == kWaitPwm;
}
inline void Instruction::set_has_waitpwm() {
  _oneof_case_[0] = kWaitPwm;
}
inline void Instruction::clear_waitpwm() {
  if (has_waitpwm()) {
    delete instruction_oneof_.waitpwm_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::WaitPwm& Instruction::_internal_waitpwm() const {
  return *instruction_oneof_.waitpwm_;
}
inline ::blox_test::Sequence::WaitPwm* Instruction::release_waitpwm() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitPwm)
  if (has_waitpwm()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::WaitPwm* temp = instruction_oneof_.waitpwm_;
    instruction_oneof_.waitpwm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::WaitPwm& Instruction::waitpwm() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitPwm)
  return has_waitpwm()
      ? *instruction_oneof_.waitpwm_
      : *reinterpret_cast< ::blox_test::Sequence::WaitPwm*>(&::blox_test::Sequence::_WaitPwm_default_instance_);
}
inline ::blox_test::Sequence::WaitPwm* Instruction::mutable_waitpwm() {
  if (!has_waitpwm()) {
    clear_instruction_oneof();
    set_has_waitpwm();
    instruction_oneof_.waitpwm_ = CreateMaybeMessage< ::blox_test::Sequence::WaitPwm >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitPwm)
  return instruction_oneof_.waitpwm_;
}

// .blox_test.Sequence.StartWaitProfile startProfile = 15;
inline bool Instruction::has_startprofile() const {
  return instruction_oneof_case() == kStartProfile;
}
inline void Instruction::set_has_startprofile() {
  _oneof_case_[0] = kStartProfile;
}
inline void Instruction::clear_startprofile() {
  if (has_startprofile()) {
    delete instruction_oneof_.startprofile_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::_internal_startprofile() const {
  return *instruction_oneof_.startprofile_;
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::release_startprofile() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.startProfile)
  if (has_startprofile()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitProfile* temp = instruction_oneof_.startprofile_;
    instruction_oneof_.startprofile_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::startprofile() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.startProfile)
  return has_startprofile()
      ? *instruction_oneof_.startprofile_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitProfile*>(&::blox_test::Sequence::_StartWaitProfile_default_instance_);
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::mutable_startprofile() {
  if (!has_startprofile()) {
    clear_instruction_oneof();
    set_has_startprofile();
    instruction_oneof_.startprofile_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitProfile >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.startProfile)
  return instruction_oneof_.startprofile_;
}

// .blox_test.Sequence.StartWaitProfile waitProfile = 16;
inline bool Instruction::has_waitprofile() const {
  return instruction_oneof_case() == kWaitProfile;
}
inline void Instruction::set_has_waitprofile() {
  _oneof_case_[0] = kWaitProfile;
}
inline void Instruction::clear_waitprofile() {
  if (has_waitprofile()) {
    delete instruction_oneof_.waitprofile_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::_internal_waitprofile() const {
  return *instruction_oneof_.waitprofile_;
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::release_waitprofile() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitProfile)
  if (has_waitprofile()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitProfile* temp = instruction_oneof_.waitprofile_;
    instruction_oneof_.waitprofile_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitProfile& Instruction::waitprofile() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitProfile)
  return has_waitprofile()
      ? *instruction_oneof_.waitprofile_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitProfile*>(&::blox_test::Sequence::_StartWaitProfile_default_instance_);
}
inline ::blox_test::Sequence::StartWaitProfile* Instruction::mutable_waitprofile() {
  if (!has_waitprofile()) {
    clear_instruction_oneof();
    set_has_waitprofile();
    instruction_oneof_.waitprofile_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitProfile >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitProfile)
  return instruction_oneof_.waitprofile_;
}

// .blox_test.Sequence.StartWaitSequence startSequence = 17;
inline bool Instruction::has_startsequence() const {
  return instruction_oneof_case() == kStartSequence;
}
inline void Instruction::set_has_startsequence() {
  _oneof_case_[0] = kStartSequence;
}
inline void Instruction::clear_startsequence() {
  if (has_startsequence()) {
    delete instruction_oneof_.startsequence_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::_internal_startsequence() const {
  return *instruction_oneof_.startsequence_;
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::release_startsequence() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.startSequence)
  if (has_startsequence()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitSequence* temp = instruction_oneof_.startsequence_;
    instruction_oneof_.startsequence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::startsequence() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.startSequence)
  return has_startsequence()
      ? *instruction_oneof_.startsequence_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitSequence*>(&::blox_test::Sequence::_StartWaitSequence_default_instance_);
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::mutable_startsequence() {
  if (!has_startsequence()) {
    clear_instruction_oneof();
    set_has_startsequence();
    instruction_oneof_.startsequence_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitSequence >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.startSequence)
  return instruction_oneof_.startsequence_;
}

// .blox_test.Sequence.StartWaitSequence waitSequence = 18;
inline bool Instruction::has_waitsequence() const {
  return instruction_oneof_case() == kWaitSequence;
}
inline void Instruction::set_has_waitsequence() {
  _oneof_case_[0] = kWaitSequence;
}
inline void Instruction::clear_waitsequence() {
  if (has_waitsequence()) {
    delete instruction_oneof_.waitsequence_;
    clear_has_instruction_oneof();
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::_internal_waitsequence() const {
  return *instruction_oneof_.waitsequence_;
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::release_waitsequence() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Instruction.waitSequence)
  if (has_waitsequence()) {
    clear_has_instruction_oneof();
      ::blox_test::Sequence::StartWaitSequence* temp = instruction_oneof_.waitsequence_;
    instruction_oneof_.waitsequence_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::StartWaitSequence& Instruction::waitsequence() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Instruction.waitSequence)
  return has_waitsequence()
      ? *instruction_oneof_.waitsequence_
      : *reinterpret_cast< ::blox_test::Sequence::StartWaitSequence*>(&::blox_test::Sequence::_StartWaitSequence_default_instance_);
}
inline ::blox_test::Sequence::StartWaitSequence* Instruction::mutable_waitsequence() {
  if (!has_waitsequence()) {
    clear_instruction_oneof();
    set_has_waitsequence();
    instruction_oneof_.waitsequence_ = CreateMaybeMessage< ::blox_test::Sequence::StartWaitSequence >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Instruction.waitSequence)
  return instruction_oneof_.waitsequence_;
}

inline bool Instruction::has_instruction_oneof() const {
  return instruction_oneof_case() != INSTRUCTION_ONEOF_NOT_SET;
}
inline void Instruction::clear_has_instruction_oneof() {
  _oneof_case_[0] = INSTRUCTION_ONEOF_NOT_SET;
}
inline Instruction::InstructionOneofCase Instruction::instruction_oneof_case() const {
  return Instruction::InstructionOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InstructionReset

// uint32 activeInstruction = 1 [(.nanopb) = {
inline void InstructionReset::clear_activeinstruction() {
  activeinstruction_ = 0u;
}
inline ::google::protobuf::uint32 InstructionReset::activeinstruction() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.InstructionReset.activeInstruction)
  return activeinstruction_;
}
inline void InstructionReset::set_activeinstruction(::google::protobuf::uint32 value) {
  
  activeinstruction_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.InstructionReset.activeInstruction)
}

// uint32 activeInstructionStartedAt = 2 [(.nanopb) = {
inline void InstructionReset::clear_activeinstructionstartedat() {
  activeinstructionstartedat_ = 0u;
}
inline ::google::protobuf::uint32 InstructionReset::activeinstructionstartedat() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.InstructionReset.activeInstructionStartedAt)
  return activeinstructionstartedat_;
}
inline void InstructionReset::set_activeinstructionstartedat(::google::protobuf::uint32 value) {
  
  activeinstructionstartedat_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.InstructionReset.activeInstructionStartedAt)
}

// -------------------------------------------------------------------

// Block

// bool enabled = 1 [(.brewblox.field) = {
inline void Block::clear_enabled() {
  enabled_ = false;
}
inline bool Block::enabled() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.enabled)
  return enabled_;
}
inline void Block::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.enabled)
}

// repeated .blox_test.Sequence.Instruction instructions = 2;
inline int Block::instructions_size() const {
  return instructions_.size();
}
inline void Block::clear_instructions() {
  instructions_.Clear();
}
inline ::blox_test::Sequence::Instruction* Block::mutable_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Block.instructions)
  return instructions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >*
Block::mutable_instructions() {
  // @@protoc_insertion_point(field_mutable_list:blox_test.Sequence.Block.instructions)
  return &instructions_;
}
inline const ::blox_test::Sequence::Instruction& Block::instructions(int index) const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.instructions)
  return instructions_.Get(index);
}
inline ::blox_test::Sequence::Instruction* Block::add_instructions() {
  // @@protoc_insertion_point(field_add:blox_test.Sequence.Block.instructions)
  return instructions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox_test::Sequence::Instruction >&
Block::instructions() const {
  // @@protoc_insertion_point(field_list:blox_test.Sequence.Block.instructions)
  return instructions_;
}

// .blox_test.Sequence.InstructionReset reset = 3;
inline bool Block::has_reset() const {
  return reset_oneof_case() == kReset;
}
inline void Block::set_has_reset() {
  _oneof_case_[0] = kReset;
}
inline void Block::clear_reset() {
  if (has_reset()) {
    delete reset_oneof_.reset_;
    clear_has_reset_oneof();
  }
}
inline const ::blox_test::Sequence::InstructionReset& Block::_internal_reset() const {
  return *reset_oneof_.reset_;
}
inline ::blox_test::Sequence::InstructionReset* Block::release_reset() {
  // @@protoc_insertion_point(field_release:blox_test.Sequence.Block.reset)
  if (has_reset()) {
    clear_has_reset_oneof();
      ::blox_test::Sequence::InstructionReset* temp = reset_oneof_.reset_;
    reset_oneof_.reset_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::blox_test::Sequence::InstructionReset& Block::reset() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.reset)
  return has_reset()
      ? *reset_oneof_.reset_
      : *reinterpret_cast< ::blox_test::Sequence::InstructionReset*>(&::blox_test::Sequence::_InstructionReset_default_instance_);
}
inline ::blox_test::Sequence::InstructionReset* Block::mutable_reset() {
  if (!has_reset()) {
    clear_reset_oneof();
    set_has_reset();
    reset_oneof_.reset_ = CreateMaybeMessage< ::blox_test::Sequence::InstructionReset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:blox_test.Sequence.Block.reset)
  return reset_oneof_.reset_;
}

// uint32 activeInstruction = 4 [(.nanopb) = {
inline void Block::clear_activeinstruction() {
  activeinstruction_ = 0u;
}
inline ::google::protobuf::uint32 Block::activeinstruction() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.activeInstruction)
  return activeinstruction_;
}
inline void Block::set_activeinstruction(::google::protobuf::uint32 value) {
  
  activeinstruction_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.activeInstruction)
}

// uint32 activeInstructionStartedAt = 5 [(.nanopb) = {
inline void Block::clear_activeinstructionstartedat() {
  activeinstructionstartedat_ = 0u;
}
inline ::google::protobuf::uint32 Block::activeinstructionstartedat() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.activeInstructionStartedAt)
  return activeinstructionstartedat_;
}
inline void Block::set_activeinstructionstartedat(::google::protobuf::uint32 value) {
  
  activeinstructionstartedat_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.activeInstructionStartedAt)
}

// uint32 disabledAt = 6 [(.nanopb) = {
inline void Block::clear_disabledat() {
  disabledat_ = 0u;
}
inline ::google::protobuf::uint32 Block::disabledat() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.disabledAt)
  return disabledat_;
}
inline void Block::set_disabledat(::google::protobuf::uint32 value) {
  
  disabledat_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.disabledAt)
}

// uint32 disabledDuration = 7 [(.nanopb) = {
inline void Block::clear_disabledduration() {
  disabledduration_ = 0u;
}
inline ::google::protobuf::uint32 Block::disabledduration() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.disabledDuration)
  return disabledduration_;
}
inline void Block::set_disabledduration(::google::protobuf::uint32 value) {
  
  disabledduration_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.disabledDuration)
}

// .blox_test.Sequence.SequenceStatus status = 8 [(.brewblox.field) = {
inline void Block::clear_status() {
  status_ = 0;
}
inline ::blox_test::Sequence::SequenceStatus Block::status() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.status)
  return static_cast< ::blox_test::Sequence::SequenceStatus >(status_);
}
inline void Block::set_status(::blox_test::Sequence::SequenceStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.status)
}

// .blox_test.Sequence.SequenceError error = 9 [(.brewblox.field) = {
inline void Block::clear_error() {
  error_ = 0;
}
inline ::blox_test::Sequence::SequenceError Block::error() const {
  // @@protoc_insertion_point(field_get:blox_test.Sequence.Block.error)
  return static_cast< ::blox_test::Sequence::SequenceError >(error_);
}
inline void Block::set_error(::blox_test::Sequence::SequenceError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:blox_test.Sequence.Block.error)
}

inline bool Block::has_reset_oneof() const {
  return reset_oneof_case() != RESET_ONEOF_NOT_SET;
}
inline void Block::clear_has_reset_oneof() {
  _oneof_case_[0] = RESET_ONEOF_NOT_SET;
}
inline Block::ResetOneofCase Block::reset_oneof_case() const {
  return Block::ResetOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Sequence
}  // namespace blox_test

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::blox_test::Sequence::SequenceStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox_test::Sequence::SequenceStatus>() {
  return ::blox_test::Sequence::SequenceStatus_descriptor();
}
template <> struct is_proto_enum< ::blox_test::Sequence::SequenceError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox_test::Sequence::SequenceError>() {
  return ::blox_test::Sequence::SequenceError_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Sequence_5ftest_2eproto
